backend/config/database.js:
// Database configuration and setup
const Database = require('better-sqlite3');
const path = require('path');
const { log } = require('../utils/logger');
const fs = require('fs');
// Ensure userdata directory exists
let userdataDir;
if (process.env.PORTABLE_USERDATA_PATH) {
// Electron portable mode - use path set by main process
userdataDir = process.env.PORTABLE_USERDATA_PATH;
} else {
// Running as normal Node.js - use project directory
userdataDir = path.join(__dirname, '..', '..', 'userdata');
}
if (!fs.existsSync(userdataDir)) {
fs.mkdirSync(userdataDir, { recursive: true });
}
// Database file path
const dbPath = path.join(userdataDir, 'chats.db');
// Database connection - initialize immediately with basic connection
// This ensures db is never undefined when imported
let db = new Database(dbPath);
// Initialize database schema
function initializeDatabase() {
return new Promise((resolve, reject) => {
try {
// Create tables
db.exec(`CREATE TABLE IF NOT EXISTS chats (
id TEXT PRIMARY KEY,
title TEXT NOT NULL,
created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
)`);
// Settings table for application configuration
db.exec(`CREATE TABLE IF NOT EXISTS settings (
key TEXT PRIMARY KEY,
value TEXT NOT NULL
)`);
// Add turn_number to chats table for proper turn tracking
try {
db.exec(`ALTER TABLE chats ADD COLUMN turn_number INTEGER DEFAULT 0`);
} catch (err) {
// Column likely already exists
if (!err.message.includes('duplicate column name')) {
log('[DB] Error adding turn_number to chats:', err.message);
}
}
// Everything-is-a-branch system: Every chat gets a main branch from creation
db.exec(`CREATE TABLE IF NOT EXISTS chat_branches (
id INTEGER PRIMARY KEY AUTOINCREMENT,
chat_id TEXT NOT NULL,
branch_name TEXT NOT NULL,
parent_branch_id INTEGER,
branch_point_turn INTEGER,
is_active BOOLEAN DEFAULT FALSE,
created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
UNIQUE(chat_id, branch_name),
FOREIGN KEY (chat_id) REFERENCES chats (id),
FOREIGN KEY (parent_branch_id) REFERENCES chat_branches (id)
)`);
// This is now the ONLY message table - everything goes through branches
db.exec(`CREATE TABLE IF NOT EXISTS branch_messages (
id INTEGER PRIMARY KEY AUTOINCREMENT,
branch_id INTEGER NOT NULL,
original_message_id INTEGER,
role TEXT NOT NULL,
content TEXT NOT NULL,
turn_number INTEGER NOT NULL,
tool_calls TEXT,
tool_call_id TEXT,
tool_name TEXT,
blocks TEXT,
debug_data TEXT,
edit_count INTEGER DEFAULT 0,
edited_at DATETIME,
timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
FOREIGN KEY (branch_id) REFERENCES chat_branches (id)
)`);
// Add new fields for file handling separation
try {
db.exec(`ALTER TABLE branch_messages ADD COLUMN original_content TEXT`);
log('[DB] Added original_content column to branch_messages');
} catch (err) {
// Column likely already exists
if (!err.message.includes('duplicate column name')) {
log('[DB] Error adding original_content:', err.message);
}
}
try {
db.exec(`ALTER TABLE branch_messages ADD COLUMN file_metadata TEXT`);
log('[DB] Added file_metadata column to branch_messages');
} catch (err) {
// Column likely already exists
if (!err.message.includes('duplicate column name')) {
log('[DB] Error adding file_metadata:', err.message);
}
}
// Add error_state column for tracking errored messages
try {
db.exec(`ALTER TABLE branch_messages ADD COLUMN error_state TEXT DEFAULT NULL`);
log('[DB] Added error_state column to branch_messages');
} catch (err) {
// Column likely already exists
if (!err.message.includes('duplicate column name')) {
log('[DB] Error adding error_state:', err.message);
}
}
// FULL MIGRATION: Move everything to branch-based system and drop old tables
try {
log('[DB] Starting FULL migration to everything-is-a-branch system...');
// Step 1: Migrate any remaining data from old messages table
const oldTableExists = db.prepare(`
SELECT name FROM sqlite_master
WHERE type='table' AND name='messages'
`).get();
if (oldTableExists) {
log('[DB] Found old messages table, migrating data...');
// Get all chats that have messages but no main branch
const chatsWithoutBranchStmt = db.prepare(`
SELECT DISTINCT m.chat_id
FROM messages m
LEFT JOIN chat_branches cb ON m.chat_id = cb.chat_id AND cb.branch_name = 'main'
WHERE cb.id IS NULL
ORDER BY m.chat_id
`);
const chatsWithoutBranch = chatsWithoutBranchStmt.all();
for (const chat of chatsWithoutBranch) {
// Create main branch for this chat
const insertBranchStmt = db.prepare(`
INSERT INTO chat_branches (chat_id, branch_name, parent_branch_id,
branch_point_turn, is_active)
VALUES (?, 'main', NULL, NULL, TRUE)
`);
const branchResult = insertBranchStmt.run(chat.chat_id);
const branchId = branchResult.lastInsertRowid;
// Get all messages for this chat
const messagesStmt = db.prepare(`
SELECT id, role, content, turn_number, tool_calls, tool_call_id, tool_name,
blocks, debug_data, edit_count, edited_at, timestamp
FROM messages
WHERE chat_id = ?
ORDER BY timestamp ASC
`);
const messages = messagesStmt.all(chat.chat_id);
// Copy all messages to main branch
const insertMessageStmt = db.prepare(`
INSERT INTO branch_messages
(branch_id, original_message_id, role, content, turn_number, tool_calls,
tool_call_id, tool_name, blocks, debug_data, edit_count, edited_at, timestamp)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`);
for (const msg of messages) {
insertMessageStmt.run(
branchId, msg.id, msg.role, msg.content, msg.turn_number || 1,
msg.tool_calls, msg.tool_call_id, msg.tool_name, msg.blocks, msg.debug_data,
msg.edit_count || 0, msg.edited_at, msg.timestamp
);
}
log(`[DB] Migrated chat ${chat.chat_id} to main branch with ${messages.length}
messages`);
}
// Step 2: Migrate debug data from turn_debug_data to branch_messages
log('[DB] Migrating debug data to branch messages...');
const debugDataExists = db.prepare(`
SELECT name FROM sqlite_master
WHERE type='table' AND name='turn_debug_data'
`).get();
if (debugDataExists) {
// Get all debug data
const debugDataStmt = db.prepare(`
SELECT chat_id, turn_number, debug_data
FROM turn_debug_data
`);
const debugDataRows = debugDataStmt.all();
// Update branch_messages with debug data
const updateDebugStmt = db.prepare(`
UPDATE branch_messages
SET debug_data = ?
WHERE branch_id IN (
SELECT cb.id FROM chat_branches cb
WHERE cb.chat_id = ? AND cb.branch_name = 'main'
)
AND turn_number = ?
AND debug_data IS NULL
`);
for (const debugRow of debugDataRows) {
updateDebugStmt.run(debugRow.debug_data, debugRow.chat_id,
debugRow.turn_number);
}
log(`[DB] Migrated ${debugDataRows.length} debug data entries to branch messages`);
}
// Step 3: Drop old tables after successful migration
log('[DB] Dropping old tables...');
db.exec('DROP TABLE IF EXISTS messages');
db.exec('DROP TABLE IF EXISTS turn_debug_data');
log('[DB] Successfully dropped old tables: messages, turn_debug_data');
}
// Step 4: Ensure ALL existing chats have main branches
const chatsWithoutMainBranchStmt = db.prepare(`
SELECT c.id
FROM chats c
LEFT JOIN chat_branches cb ON c.id = cb.chat_id AND cb.branch_name = 'main'
WHERE cb.id IS NULL
`);
const chatsWithoutMainBranch = chatsWithoutMainBranchStmt.all();
const createMainBranchStmt = db.prepare(`
INSERT INTO chat_branches (chat_id, branch_name, parent_branch_id, branch_point_turn,
is_active)
VALUES (?, 'main', NULL, NULL, TRUE)
`);
for (const chat of chatsWithoutMainBranch) {
createMainBranchStmt.run(chat.id);
log(`[DB] Created main branch for existing chat ${chat.id}`);
}
backend/services/chatService.js:
log(`[DB] FULL migration to everything-is-a-branch completed!`);
} catch (migrationError) {
log('[DB] Error during full migration:', migrationError.message);
// Don't fail initialization if migration fails, but log it clearly
log('[DB] MIGRATION FAILED - system may have inconsistent state');
}
log('[DB] Database initialized successfully');
resolve();
} catch (err) {
log('[DB] Error initializing database:', err.message);
reject(err);
}
});
}
// Graceful database shutdown
function closeDatabase() {
return new Promise((resolve) => {
try {
if (db) {
db.close();
log('[DATABASE] Closed successfully.');
}
resolve();
} catch (err) {
log('[DATABASE] Error closing database:', err.message);
resolve();
}
});
}
module.exports = {
db, // Export the database instance directly
initializeDatabase,
closeDatabase
};
// Chat Service - Handle AI chat logic, streaming, and tool execution with adapters per api
// ===== NEW FILE HANDLING FUNCTIONS =====
/**
* Extract file content from multimodal message content
* @param {Array|string} content - Message content (array for multimodal, string for text-only)
* @returns {Object} - { textContent, files, images, hasFiles }
*/
function extractFilesFromContent(content) {
// Initialize return object
const result = {
textContent: '',
files: [],
images: [],
hasFiles: false
};
if (typeof content === 'string') {
// Simple text content, no files
result.textContent = content;
return result;
}
if (!Array.isArray(content)) {
// Unknown content type, treat as text
result.textContent = String(content || '');
return result;
}
// Process multimodal array content
content.forEach(part => {
if (part.type === 'text') {
result.textContent = part.text || '';
} else if (part.type === 'image') {
result.images.push(part);
} else if (part.type === 'files' && part.files && Array.isArray(part.files)) {
// New file structure
result.files = part.files;
result.hasFiles = true;
}
});
return result;
}
/**
* Concatenate file content to text content for AI processing
* @param {string} textContent - Original user text
* @param {Array} files - Array of file objects with extractedText
* @returns {string} - Concatenated content ready for AI
*/
function concatenateFileContent(textContent, files) {
let finalText = textContent || '';
if (files && Array.isArray(files) && files.length > 0) {
files.forEach(file => {
if (file.extractedText) {
finalText += `\n\n\`\`\`userdocument\nFile:
${file.fileName}\n${file.extractedText}\n\`\`\``;
}
});
log(`[FILE-PROCESSING] Concatenated ${files.length} file(s) to message content`);
}
return finalText;
}
/**
* Create multimodal content with separated files for storage
* This preserves the original structure while also providing concatenated content for AI
* @param {string} userText - User's actual text input
* @param {Array} files - File objects array
* @param {Array} images - Image objects array
* @returns {Object} - { originalContent, concatenatedContent }
*/
function createSeparatedFileContent(userText, files, images) {
const hasFiles = files && files.length > 0;
const hasImages = images && images.length > 0;
let originalContent, concatenatedContent;
if (hasFiles || hasImages) {
// Create multimodal array preserving file structure
originalContent = [];
// Add text part
if (userText || hasFiles) {
originalContent.push({
type: 'text',
text: userText || ''
});
}
// Add images
if (hasImages) {
originalContent.push(...images);
}
// Add files as separate part
if (hasFiles) {
originalContent.push({
type: 'files',
files: files
});
}
// Create concatenated version for AI
concatenatedContent = concatenateFileContent(userText, files);
} else {
// Simple text content
originalContent = userText || '';
concatenatedContent = userText || '';
}
return { originalContent, concatenatedContent };
}
/**
* Process message content for AI consumption
* Extracts files and creates concatenated content while preserving original structure
* @param {Array|string} messageContent - Original message content from frontend
* @returns {Object} - { aiContent, originalContent, fileMetadata }
*/
function processMessageForAI(messageContent) {
const extracted = extractFilesFromContent(messageContent);
const { textContent, files, images, hasFiles } = extracted;
let aiContent;
if (hasFiles || images.length > 0) {
// Create multimodal content for AI with concatenated text
aiContent = [];
// Add concatenated text (user text + file contents)
const concatenatedText = concatenateFileContent(textContent, files);
if (concatenatedText) {
aiContent.push({
type: 'text',
text: concatenatedText
});
}
// Add images (unchanged)
if (images.length > 0) {
aiContent.push(...images);
}
} else {
// Simple text content
aiContent = textContent;
}
return {
aiContent,
originalContent: messageContent,
fileMetadata: {
hasFiles,
fileCount: files.length,
imageCount: images.length,
files: files
}
};
}
const https = require('https');
const http = require('http');
const { log } = require('../utils/logger');
// Simple debug flag for adapter logs - set DEBUG=1 to enable
const DEBUG_ADAPTERS = process.env.DEBUG === '1';
const { getCurrentSettings } = require('./settingsService');
const { executeMCPTool, getAvailableToolsForChat } = require('./mcpService');
const { addToolEvent, storeDebugData } = require('./toolEventService');
// Update debug data for the most recent message of a specific role in a turn
async function updateMessageDebugData(chatId, role, turnNumber, debugData) {
const { db } = require('../config/database');
try {
const debugDataJson = debugData ? JSON.stringify(debugData) : null;
// Update the most recent message of the specified role in the specified turn
const updateStmt = db.prepare(
'UPDATE messages SET debug_data = ? WHERE chat_id = ? AND role = ? AND turn_number = ? AND id =
(SELECT MAX(id) FROM messages WHERE chat_id = ? AND role = ? AND turn_number = ?)'
);
const result = updateStmt.run(debugDataJson, chatId, role, turnNumber, chatId, role, turnNumber);
if (result.changes > 0) {
log(`[CHAT-UPDATE] Updated debug data for ${role} message in turn ${turnNumber}`);
} else {
log(`[CHAT-UPDATE] No message found to update for ${role} in turn ${turnNumber}`);
}
} catch (err) {
log('[CHAT-UPDATE] Error updating message debug data:', err);
throw err;
}
}
// Turn-based debug data functions
async function saveTurnDebugData(chatId, turnNumber, debugData) {
const { db } = require('../config/database');
try {
const debugDataJson = JSON.stringify(debugData);
// Get active branch for this chat
const activeBranch = getActiveChatBranch(chatId);
if (!activeBranch) {
log(`[TURN-DEBUG] No active branch found for chat ${chatId}, cannot save debug data`);
return null;
}
// First check if a message exists for this turn
const checkStmt = db.prepare(`
SELECT id FROM branch_messages
WHERE branch_id = ? AND turn_number = ?
LIMIT 1
`);
const existing = checkStmt.get(activeBranch.id, turnNumber);
let result;
if (existing) {
// Update existing message
const updateStmt = db.prepare(`
UPDATE branch_messages
SET debug_data = ?
WHERE branch_id = ? AND turn_number = ?
`);
result = updateStmt.run(debugDataJson, activeBranch.id, turnNumber);
} else {
// Insert placeholder message with debug data
const insertStmt = db.prepare(`
INSERT INTO branch_messages (branch_id, turn_number, role, content, debug_data, timestamp)
VALUES (?, ?, 'user', '', ?, datetime('now'))
`);
result = insertStmt.run(activeBranch.id, turnNumber, debugDataJson);
}
log(`[TURN-DEBUG] Updated debug data for turn ${turnNumber} in chat ${chatId} (branch:
${activeBranch.branch_name})`);
return result;
} catch (err) {
log('[TURN-DEBUG] Error saving turn debug data:', err);
throw err;
}
}
function getTurnDebugData(chatId, turnNumber) {
const { db } = require('../config/database');
try {
// Get active branch for this chat
const activeBranch = getActiveChatBranch(chatId);
if (!activeBranch) {
log(`[TURN-DEBUG] No active branch found for chat ${chatId}`);
return null;
}
// Get debug data from branch_messages for the specific turn
const stmt = db.prepare(`
SELECT debug_data
FROM branch_messages
WHERE branch_id = ? AND turn_number = ? AND debug_data IS NOT NULL
LIMIT 1
`);
const result = stmt.get(activeBranch.id, turnNumber);
if (result && result.debug_data) {
const debugData = JSON.parse(result.debug_data);
log(`[TURN-DEBUG] Retrieved debug data for turn ${turnNumber} in chat ${chatId} (branch:
${activeBranch.branch_name})`);
return debugData;
} else {
log(`[TURN-DEBUG] No debug data found for turn ${turnNumber} in chat ${chatId}`);
return null;
}
} catch (err) {
log('[TURN-DEBUG] Error getting turn debug data:', err);
return null;
}
}
function getAllTurnDebugData(chatId) {
const { db } = require('../config/database');
try {
// Get active branch for this chat
const activeBranch = getActiveChatBranch(chatId);
if (!activeBranch) {
log(`[TURN-DEBUG] No active branch found for chat ${chatId}`);
return {};
}
// Get all debug data from branch_messages
const stmt = db.prepare(`
SELECT turn_number, debug_data
FROM branch_messages
WHERE branch_id = ? AND debug_data IS NOT NULL
ORDER BY turn_number ASC
`);
const rows = stmt.all(activeBranch.id);
const turnDebugMap = {};
rows.forEach(row => {
try {
turnDebugMap[row.turn_number] = JSON.parse(row.debug_data);
} catch (parseError) {
log(`[TURN-DEBUG] Error parsing debug data for turn ${row.turn_number}:`, parseError);
}
});
log(`[TURN-DEBUG] Retrieved debug data for ${rows.length} turns in chat ${chatId} (branch:
${activeBranch.branch_name})`);
return turnDebugMap;
} catch (err) {
log('[TURN-DEBUG] Error getting all turn debug data:', err);
return {};
}
}
// Get current turn number for a chat
function getCurrentTurnNumber(chat_id) {
if (!chat_id) {
return 0; // Default to turn 0
}
const { db } = require('../config/database');
try {
const stmt = db.prepare('SELECT turn_number FROM chats WHERE id = ?');
const result = stmt.get(chat_id);
const currentTurn = result ? (result.turn_number || 0) : 0;
log(`[CURRENT-TURN] Chat ${chat_id}: current turn = ${currentTurn}`);
return currentTurn;
} catch (err) {
log('[CHAT-TURN] Error getting current turn:', err);
return 0; // Default to turn 0 on error
}
}
function incrementTurnNumber(chat_id) {
if (!chat_id) {
return;
}
const { db } = require('../config/database');
try {
const stmt = db.prepare('UPDATE chats SET turn_number = turn_number + 1 WHERE id = ?');
const result = stmt.run(chat_id);
if (result.changes > 0) {
const newTurn = getCurrentTurnNumber(chat_id);
log(`[INCREMENT-TURN] Chat ${chat_id}: incremented to turn ${newTurn}`);
} else {
log(`[INCREMENT-TURN] Chat ${chat_id}: no chat found to increment`);
}
} catch (err) {
log('[INCREMENT-TURN] Error incrementing turn:', err);
}
}
function getChatHistoryForAPI(chat_id) {
if (!chat_id) {
return [];
}
const { db } = require('../config/database');
const messages = [];
try {
// Everything-is-a-branch system: Always use the active branch
log(`[CHAT-HISTORY] Getting history from active branch for chat ${chat_id}`);
// Get the active branch
const activeBranchStmt = db.prepare(`
SELECT id, branch_name
FROM chat_branches
WHERE chat_id = ? AND is_active = TRUE
LIMIT 1
`);
const activeBranch = activeBranchStmt.get(chat_id);
if (!activeBranch) {
log(`[CHAT-HISTORY] No active branch found for chat ${chat_id} - this shouldn't happen in
everything-is-a-branch system`);
return [];
}
// Get all messages from the active branch including new file fields
// FILTER OUT ERROR MESSAGES: Only include successful messages in AI history
const messagesStmt = db.prepare(`
SELECT role, content, turn_number, tool_calls, tool_call_id, tool_name, original_content,
file_metadata
FROM branch_messages
WHERE branch_id = ? AND error_state IS NULL
ORDER BY timestamp ASC
`);
const branchMessages = messagesStmt.all(activeBranch.id);
log(`[CHAT-HISTORY] Retrieved ${branchMessages.length} successful messages (errors filtered out)`);
branchMessages.forEach(row => {
// Process saved messages to ensure AI gets correct content
let finalContent = row.content;
// If this message has original content and file metadata, we need to process it for AI
if (row.original_content && row.file_metadata) {
try {
const originalContent = typeof row.original_content === 'string' &&
row.original_content.startsWith('[')
? JSON.parse(row.original_content)
: row.original_content;
const fileMetadata = JSON.parse(row.file_metadata);
// If there are files, re-process for AI to get concatenated content
if (fileMetadata.hasFiles) {
const processedMessage = processMessageForAI(originalContent);
finalContent = processedMessage.aiContent;
log(`[CHAT-HISTORY] Reprocessed message with ${fileMetadata.fileCount} file(s) for
AI`);
}
} catch (e) {
log(`[CHAT-HISTORY] Error processing file metadata: ${e.message}`);
// Fall back to stored content
}
}
// Parse content - handle both string and JSON (multimodal) content
let parsedContent = finalContent;
if (typeof finalContent === 'string' && finalContent.startsWith('[')) {
try {
// Try to parse as JSON array (multimodal content)
parsedContent = JSON.parse(finalContent);
} catch (e) {
// If parsing fails, keep as string
parsedContent = finalContent;
}
}
const message = {
role: row.role,
content: parsedContent,
turn_number: row.turn_number
};
// Add tool data if present
if (row.tool_calls) {
try {
message.tool_calls = JSON.parse(row.tool_calls);
} catch (e) {
log(`[CHAT-HISTORY] Error parsing tool_calls: ${e.message}`);
}
}
if (row.tool_call_id) {
message.tool_call_id = row.tool_call_id;
}
if (row.tool_name) {
message.tool_name = row.tool_name;
}
messages.push(message);
});
log(`[CHAT-HISTORY] Retrieved ${messages.length} messages from branch
'${activeBranch.branch_name}'`);
return messages;
} catch (err) {
log('[CHAT-HISTORY] Error getting chat history:', err);
throw new Error(`Failed to load chat history: ${err.message}`);
}
}
// Save complete message structure to database (everything-is-a-branch system)
async function saveCompleteMessageToDatabase(chatId, messageData, blocks = null, turnNumber = null,
errorState = null) {
// Everything goes through branches now - this is just a wrapper for saveMessageToBranch
return await saveMessageToBranch(chatId, messageData, blocks, turnNumber, errorState);
}
// Save message to current active branch (everything-is-a-branch system)
async function saveMessageToBranch(chatId, messageData, blocks = null, turnNumber = null, errorState = null)
{
const { db } = require('../config/database');
try {
// Get active branch
const activeBranch = getActiveChatBranch(chatId);
if (!activeBranch) {
// No branches exist, create main branch first
log(`[BRANCHING] No active branch for chat ${chatId}, creating main branch`);
const newBranch = await createChatBranch(chatId);
await setActiveChatBranch(chatId, newBranch.branchId);
return saveMessageToBranch(chatId, messageData, blocks, turnNumber);
}
// Prepare message data
const content = Array.isArray(messageData.content)
? JSON.stringify(messageData.content) // JSON stringify multimodal content
: messageData.content || ''; // Keep strings as-is
const role = messageData.role || 'user';
const toolCalls = messageData.tool_calls ? JSON.stringify(messageData.tool_calls) : null;
const toolCallId = messageData.tool_call_id || null;
const toolName = messageData.tool_name || null;
const blocksJson = blocks ? JSON.stringify(blocks) : null;
const debugData = messageData.debug_data ? JSON.stringify(messageData.debug_data) : null;
// Handle original content and file metadata
const originalContent = messageData.originalContent
? (Array.isArray(messageData.originalContent)
? JSON.stringify(messageData.originalContent)
: messageData.originalContent)
: null;
const fileMetadata = messageData.fileMetadata ? JSON.stringify(messageData.fileMetadata) : null;
// Use turn number or get next
let finalTurnNumber = turnNumber;
if (finalTurnNumber === null) {
finalTurnNumber = getCurrentTurnNumber(chatId);
}
// Insert message into branch with new file handling fields and error_state
const insertStmt = db.prepare(`
INSERT INTO branch_messages
(branch_id, role, content, turn_number, tool_calls, tool_call_id, tool_name, blocks, debug_data,
original_content, file_metadata, error_state)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`);
const result = insertStmt.run(
activeBranch.id, role, content, finalTurnNumber,
toolCalls, toolCallId, toolName, blocksJson, debugData, originalContent, fileMetadata,
errorState
);
// Update chat's updated_at timestamp
const updateChatStmt = db.prepare('UPDATE chats SET updated_at = CURRENT_TIMESTAMP WHERE id = ?');
updateChatStmt.run(chatId);
log(`[BRANCHING] Saved ${role} message to branch '${activeBranch.branch_name}' (turn
${finalTurnNumber})`);
return result.lastInsertRowid;
} catch (error) {
log('[BRANCHING] Error saving message to branch:', error);
throw error;
}
}
// Import adapter system
const responseAdapterFactory = require('../adapters/ResponseAdapterFactory');
const UnifiedResponse = require('../adapters/UnifiedResponse');
// Handle chat with potential tool calls
async function handleChatWithTools(res, messages, tools, chatId, debugData = null, responseCounter = 1,
requestId = null, existingDebugData = null, conductorPhase = null, blockToolExecution = false,
blockRecursiveToolResponse = false, userTurnNumber = null) {
const currentSettings = getCurrentSettings();
// Ensure we have a model name
if (!currentSettings.modelName) {
res.status(400).json({ error: 'No model specified. Please configure a model in settings.' });
return;
}
// Get the appropriate adapter for current settings
const adapter = responseAdapterFactory.getAdapter(currentSettings);
log(`[ADAPTER] Using ${adapter.providerName} adapter`);
// Set up tool event emitter for the adapter
adapter.setToolEventEmitter((eventType, data, reqId) => {
if (reqId) {
addToolEvent(reqId, { type: eventType, data: data });
}
});
// Create unified request
const unifiedRequest = responseAdapterFactory.createUnifiedRequest(messages, tools,
currentSettings.modelName);
// Convert to provider-specific format
const requestData = adapter.convertRequest(unifiedRequest);
// Set up streaming response FIRST
if (!res.headersSent) {
const headers = {
'Content-Type': 'text/plain',
'Transfer-Encoding': 'chunked'
};
if (requestId) {
headers['X-Request-Id'] = requestId;
}
// Include the actual AI request in response headers for frontend debug panel
if (requestData) {
headers['X-Actual-Request'] = encodeURIComponent(JSON.stringify(requestData));
}
res.writeHead(200, headers);
}
// Initialize debug data and turn number
let collectedDebugData = existingDebugData;
// Use the user turn number provided by frontend
let currentTurn;
if (collectedDebugData && collectedDebugData.currentTurn) {
// Reuse existing turn from recursive calls
currentTurn = collectedDebugData.currentTurn;
} else {
// Use the turn number from frontend, or calculate if not provided
currentTurn = userTurnNumber || (chatId ? getCurrentTurnNumber(chatId) + 1 : 1);
}
// Calculate next sequence step from existing debug data to maintain sequential order across recursive
calls
let sequenceStep = 1;
if (collectedDebugData) {
const sequenceCount = (collectedDebugData.sequence && Array.isArray(collectedDebugData.sequence)) ?
collectedDebugData.sequence.length : 0;
const httpSequenceCount = (collectedDebugData.httpSequence &&
Array.isArray(collectedDebugData.httpSequence)) ? collectedDebugData.httpSequence.length : 0;
sequenceStep = sequenceCount + httpSequenceCount + 1;
}
if (debugData && requestId && !collectedDebugData) {
collectedDebugData = {
requestId: requestId,
currentTurn: currentTurn,
sequence: [],
metadata: {
endpoint: adapter.getEndpointUrl(currentSettings),
timestamp: new Date().toISOString(),
tools: tools.length,
provider: adapter.providerName,
model: currentSettings.modelName
},
rawData: {
httpResponse: {
statusCode: null,
statusMessage: null,
headers: null
},
errors: []
}
};
} else if (collectedDebugData && !collectedDebugData.currentTurn) {
// Store turn number in existing debug data if not already set
collectedDebugData.currentTurn = currentTurn;
}
// Get provider-specific URL and headers
const targetUrl = adapter.getEndpointUrl(currentSettings);
const headers = adapter.getHeaders(currentSettings);
headers['Content-Length'] = Buffer.byteLength(JSON.stringify(requestData));
if (DEBUG_ADAPTERS) {
log(`[${adapter.providerName.toUpperCase()}-DEBUG] URL:`, targetUrl);
log(`[${adapter.providerName.toUpperCase()}-DEBUG] Request Body:`, JSON.stringify(requestData, null,
2));
}
// Store the REAL request data in the user's debug data
if (chatId && currentTurn) {
try {
const userDebugData = getTurnDebugData(chatId, currentTurn);
if (userDebugData) {
// Store the ACTUAL request that gets sent to AI with real tool definitions
userDebugData.actualHttpRequest = {
url: targetUrl,
method: 'POST',
headers: { ...headers },
body: requestData // This is the REAL request with full tool definitions
};
// Save back to the same turn
saveTurnDebugData(chatId, currentTurn, userDebugData);
} else {
log('[DEBUG-STORE] FAIL - No user debug data found');
}
} catch (error) {
log('[DEBUG-STORE] ERROR:', error.message);
}
} else {
log('[DEBUG-STORE] SKIP - Missing chatId or currentTurn');
}
log('[ACTUAL-REQUEST] Sending to API:', JSON.stringify(requestData, null, 2));
const url = new URL(targetUrl);
const options = {
hostname: url.hostname,
port: url.port,
path: url.pathname + url.search,
method: 'POST',
headers: headers
};
// Create unified response object
const unifiedResponse = new UnifiedResponse().setProvider(adapter.providerName);
const context = adapter.createContext(currentSettings.modelName);
// Make HTTP request
const httpModule = url.protocol === 'https:' ? https : http;
const apiReq = httpModule.request(options, (apiRes) => {
// Capture debug data
if (collectedDebugData && collectedDebugData.rawData) {
collectedDebugData.rawData.httpResponse = {
statusCode: apiRes.statusCode,
statusMessage: apiRes.statusMessage,
headers: apiRes.headers
};
}
if (apiRes.statusCode !== 200) {
let errorData = '';
apiRes.on('data', (chunk) => {
errorData += chunk.toString();
});
apiRes.on('end', () => {
log(`[${adapter.providerName.toUpperCase()}-ERROR] Status:`, apiRes.statusCode);
log(`[${adapter.providerName.toUpperCase()}-ERROR] Response:`, errorData);
if (collectedDebugData && collectedDebugData.rawData && collectedDebugData.rawData.errors) {
collectedDebugData.rawData.errors.push({ type: 'http_error', message: errorData });
}
// Parse and show the actual API error message to the user
let userErrorMessage = `API error: ${apiRes.statusCode} ${apiRes.statusMessage}`;
try {
// Try to parse the error response and extract useful details
const errorObj = JSON.parse(errorData);
if (errorObj.error && errorObj.error.message) {
userErrorMessage = `[${apiRes.statusCode}] ${errorObj.error.message}`;
} else if (errorObj.message) {
userErrorMessage = `[${apiRes.statusCode}] ${errorObj.message}`;
} else if (errorObj.detail) {
userErrorMessage = `[${apiRes.statusCode}] ${errorObj.detail}`;
}
} catch (parseError) {
// If error response isn't JSON, show raw error data if it's reasonable length
if (errorData && errorData.length < 500) {
userErrorMessage = `[${apiRes.statusCode}] ${errorData.trim()}`;
}
}
// IMPROVED ERROR HANDLING: Save error message and burn the turn
if (chatId && currentTurn) {
const errorMessage = {
role: 'assistant',
content: userErrorMessage,
debug_data: collectedDebugData
};
saveCompleteMessageToDatabase(chatId, errorMessage, null, currentTurn, 'api_error')
.then(() => {
incrementTurnNumber(chatId); // Burn the turn
log(`[ERROR-HANDLING] Saved API error message and burned turn ${currentTurn}`);
})
.catch(saveError => {
log(`[ERROR-HANDLING] Failed to save error message: ${saveError.message}`);
});
}
res.write(userErrorMessage);
res.end();
});
return;
}
// Stream response processing
apiRes.on('data', (chunk) => {
try {
// Process chunk with adapter
const result = adapter.processChunk(chunk, unifiedResponse, context);
// Handle any events generated - THIS IS CRITICAL FOR TOOL DROPDOWNS!
for (const event of result.events) {
if (event.type === 'tool_call_detected' && requestId) {
addToolEvent(requestId, {
type: 'tool_call_detected',
data: {
name: event.data.toolName,
id: event.data.toolId
}
});
if (DEBUG_ADAPTERS) log(`[ADAPTER-TOOL-EVENT] Tool call detected:`,
event.data.toolName);
}
}
// Update context
Object.assign(context, result.context);
// Stream any new content to client
let newContent = '';
if (unifiedResponse.content && context.lastContentLength !== unifiedResponse.content.length)
{
newContent = unifiedResponse.content.slice(context.lastContentLength || 0);
if (newContent) {
res.write(newContent);
context.lastContentLength = unifiedResponse.content.length;
// Capture the actual content being sent to frontend for debug
if (collectedDebugData) {
if (!collectedDebugData.streamedContent) {
collectedDebugData.streamedContent = '';
}
collectedDebugData.streamedContent += newContent;
}
}
}
// Add to debug data (accumulate response chunks)
if (collectedDebugData) {
if (!collectedDebugData.rawResponseChunks) {
collectedDebugData.rawResponseChunks = [];
}
collectedDebugData.rawResponseChunks.push({
chunk: chunk.toString(),
timestamp: new Date().toISOString()
});
}
} catch (error) {
console.error(`[${adapter.providerName.toUpperCase()}-ADAPTER] Error processing chunk:`,
error);
if (collectedDebugData && collectedDebugData.rawData && collectedDebugData.rawData.errors) {
collectedDebugData.rawData.errors.push({ type: 'processing_error', message:
error.message });
}
}
});
apiRes.on('end', async () => {
log(`[${adapter.providerName.toUpperCase()}-ADAPTER] Stream ended`);
// Add response step to debug sequence
if (collectedDebugData && collectedDebugData.sequence) {
const responseStep = {
type: 'response',
step: sequenceStep++,
timestamp: new Date().toISOString(),
data: {
raw_http_response: {
status: collectedDebugData.rawData.httpResponse.statusCode,
provider: adapter.providerName,
response_chunks: collectedDebugData.rawResponseChunks || []
},
content: collectedDebugData.streamedContent || 'No content streamed',
has_tool_calls: unifiedResponse.hasToolCalls()
}
};
collectedDebugData.sequence.push(responseStep);
}
// Capture complete HTTP response (REAL data)
if (collectedDebugData && requestId) {
if (!collectedDebugData.httpSequence) {
collectedDebugData.httpSequence = [];
}
collectedDebugData.httpSequence.push({
type: 'http_response',
sequence: sequenceStep++,
timestamp: new Date().toISOString(),
content: unifiedResponse.content || '',
toolCalls: unifiedResponse.toolCalls || [],
hasToolCalls: unifiedResponse.hasToolCalls()
});
log(`[SEQUENTIAL-DEBUG] Captured HTTP response, hasTools:
${unifiedResponse.hasToolCalls()}`);
}
// Handle tool calls if any
if (unifiedResponse.hasToolCalls() && !blockToolExecution) {
log(`[ADAPTER] Processing ${unifiedResponse.toolCalls.length} tool calls`);
// Add tool execution steps to debug sequence
if (collectedDebugData && collectedDebugData.sequence) {
for (const toolCall of unifiedResponse.toolCalls) {
collectedDebugData.sequence.push({
type: 'tool_execution',
step: sequenceStep++,
timestamp: new Date().toISOString(),
data: {
tool_name: toolCall.function.name,
tool_id: toolCall.id,
arguments: JSON.parse(toolCall.function.arguments)
}
});
}
}
// Execute tools and continue conversation
await executeToolCallsAndContinue(
res, unifiedResponse.toolCalls, messages, tools, chatId,
unifiedResponse.content, collectedDebugData, responseCounter,
requestId, conductorPhase, blockRecursiveToolResponse, userTurnNumber
);
} else {
// No tool calls, finish response
res.end();
// Increment turn number now that conversation is complete
if (chatId) {
incrementTurnNumber(chatId);
}
// Save final assistant response to history before ending
// Save in both conductor mode and simple chat mode
if (chatId && unifiedResponse.content) {
log(`[CHAT-SAVE] About to save final assistant response:`);
log(`[CHAT-SAVE] Content length: ${unifiedResponse.content.length}`);
log(`[CHAT-SAVE] Content preview: "${unifiedResponse.content.substring(0, 200)}..."`);
log(`[CHAT-SAVE] Turn number: ${currentTurn}`);
const finalAssistantMessage = {
role: 'assistant',
content: unifiedResponse.content
};
try {
await saveCompleteMessageToDatabase(chatId, finalAssistantMessage, null,
currentTurn);
log(`[CHAT-SAVE] Successfully saved final assistant response to history`);
} catch (error) {
log(`[CHAT-SAVE] Error saving final assistant response: ${error.message}`);
}
} else {
log(`[CHAT-SAVE] NOT saving final response - chatId: ${chatId}, content length:
${unifiedResponse.content ? unifiedResponse.content.length : 'null'}`);
}
// Store debug data with complete history
if (collectedDebugData && requestId) {
// Add complete chat history to debug data
if (chatId) {
try {
// Get the complete history
collectedDebugData.completeMessageHistory = getChatHistoryForAPI(chatId);
// Get the current turn number for debug panel consistency
// This ensures "Messages In This Turn" works when reloading saved chats
collectedDebugData.currentTurnNumber = getCurrentTurnNumber(chatId);
collectedDebugData.currentTurnMessages = null; // Will be fetched by frontend as
needed
} catch (error) {
collectedDebugData.completeMessageHistory = { error: error.message };
collectedDebugData.currentTurnMessages = { error: error.message };
collectedDebugData.currentTurnNumber = null;
}
}
storeDebugData(requestId, collectedDebugData);
log(`[ADAPTER-DEBUG] Debug data stored for request:`, requestId);
}
}
});
});
apiReq.on('error', (error) => {
log(`[${adapter.providerName.toUpperCase()}] Request error:`, error);
if (collectedDebugData && collectedDebugData.rawData && collectedDebugData.rawData.errors) {
collectedDebugData.rawData.errors.push({ type: 'request_error', message: error.message });
}
// IMPROVED ERROR HANDLING: Save connection error and burn the turn
if (chatId && currentTurn) {
const errorMessage = {
role: 'assistant',
content: `Connection error: ${error.message}`,
debug_data: collectedDebugData
};
saveCompleteMessageToDatabase(chatId, errorMessage, null, currentTurn, 'connection_error')
.then(() => {
incrementTurnNumber(chatId); // Burn the turn
log(`[ERROR-HANDLING] Saved connection error and burned turn ${currentTurn}`);
})
.catch(saveError => {
log(`[ERROR-HANDLING] Failed to save connection error: ${saveError.message}`);
});
}
res.write(`Connection error: ${error.message}`);
res.end();
});
// Capture ACTUAL HTTP request payload being sent
const actualRequestPayload = JSON.stringify(requestData);
// Add to sequential debug data (real HTTP request)
if (collectedDebugData && requestId) {
if (!collectedDebugData.httpSequence) {
collectedDebugData.httpSequence = [];
}
// Only add HTTP request to debug data if it's not the first request
// The first request is initiated in the user bubble phase and already logged there
if (collectedDebugData.httpSequence.length > 0 || responseCounter > 1) {
const requestSequenceNumber = sequenceStep++;
collectedDebugData.httpSequence.push({
type: 'http_request',
sequence: requestSequenceNumber,
timestamp: new Date().toISOString(),
payload: JSON.parse(actualRequestPayload), // Store as object for debug panel
rawPayload: actualRequestPayload // Store as string for exact representation
});
} else {
log(`[SEQUENTIAL-DEBUG] Skipping first HTTP request debug - already captured in user phase`);
}
}
apiReq.write(actualRequestPayload);
apiReq.end();
}
// Execute tool calls and continue conversation
async function executeToolCallsAndContinue(res, toolCalls, messages, tools, chatId, assistantMessage,
debugData, responseCounter, requestId, conductorPhase, blockRecursiveToolResponse, userTurnNumber) {
// Get the turn number from debug data (calculated once at conversation start)
const currentTurn = debugData && debugData.currentTurn ? debugData.currentTurn : 1;
// Add assistant message with tool calls to conversation
const assistantMessageWithTools = {
role: 'assistant',
content: assistantMessage || '',
tool_calls: toolCalls
};
messages.push(assistantMessageWithTools);
// Save assistant message with tool calls to database
if (chatId) {
await saveCompleteMessageToDatabase(chatId, assistantMessageWithTools, null, currentTurn);
log(`[CHAT-SAVE] Saved assistant message with ${toolCalls.length} tool calls`);
}
// Execute each tool call
for (const toolCall of toolCalls) {
log(`[TOOL-EXECUTION] Executing tool: ${toolCall.function.name}`);
if (requestId) {
addToolEvent(requestId, {
type: 'tool_execution_start',
data: {
name: toolCall.function.name,
id: toolCall.id,
arguments: JSON.parse(toolCall.function.arguments)
}
});
}
try {
const toolArgs = JSON.parse(toolCall.function.arguments);
const toolResult = await executeMCPTool(toolCall.function.name, toolArgs);
const toolMessage = {
role: 'tool',
tool_call_id: toolCall.id,
tool_name: toolCall.function.name, // Add tool name for Gemini conversion
content: JSON.stringify(toolResult)
};
messages.push(toolMessage);
// Save tool message to database
if (chatId) {
await saveCompleteMessageToDatabase(chatId, toolMessage, null, currentTurn);
log(`[CHAT-SAVE] Saved tool response for ${toolCall.function.name}`);
}
if (requestId) {
addToolEvent(requestId, {
type: 'tool_execution_complete',
data: {
name: toolCall.function.name,
id: toolCall.id,
status: 'success',
result: toolResult
}
});
}
// Add tool result to debug sequence
if (debugData && debugData.sequence) {
// Calculate next sequence step from existing debug data
const sequenceCount = debugData.sequence.length;
const httpSequenceCount = debugData.httpSequence ? debugData.httpSequence.length : 0;
const nextStep = sequenceCount + httpSequenceCount + 1;
debugData.sequence.push({
type: 'tool_result',
step: nextStep,
timestamp: new Date().toISOString(),
data: {
tool_name: toolCall.function.name,
tool_id: toolCall.id,
status: 'success',
result: toolResult
}
});
}
} catch (error) {
log(`[TOOL-EXECUTION] Error executing tool ${toolCall.function.name}:`, error);
const errorMessage = {
role: 'tool',
tool_call_id: toolCall.id,
tool_name: toolCall.function.name, // Add tool name for Gemini conversion
content: JSON.stringify({ error: error.message })
};
messages.push(errorMessage);
// Save tool error message to database
if (chatId) {
await saveCompleteMessageToDatabase(chatId, errorMessage, null, currentTurn);
log(`[CHAT-SAVE] Saved tool error for ${toolCall.function.name}`);
}
if (requestId) {
addToolEvent(requestId, {
type: 'tool_execution_complete',
data: {
name: toolCall.function.name,
id: toolCall.id,
status: 'error',
error: error.message
}
});
}
// Add tool error to debug sequence
if (debugData && debugData.sequence) {
// Calculate next sequence step from existing debug data
const sequenceCount = debugData.sequence.length;
const httpSequenceCount = debugData.httpSequence ? debugData.httpSequence.length : 0;
const nextStep = sequenceCount + httpSequenceCount + 1;
debugData.sequence.push({
type: 'tool_result',
step: nextStep,
timestamp: new Date().toISOString(),
data: {
tool_name: toolCall.function.name,
tool_id: toolCall.id,
status: 'error',
error: error.message
}
});
}
}
}
// Continue conversation with tool results
await handleChatWithTools(res, messages, tools, chatId, debugData, responseCounter + 1, requestId,
debugData, conductorPhase, false, false, userTurnNumber);
}
// Process chat request (entry point from routes)
async function processChatRequest(req, res) {
try {
const { message, chat_id, conductor_mode, enabled_tools, conductor_phase, message_role,
block_tool_execution, block_recursive_call, request_id, user_turn_number } = req.body;
if (!message) {
return res.status(400).json({ error: 'Message is required' });
}
// Build messages for API - get chat history first
const messages = getChatHistoryForAPI(chat_id);
// Log what's in history
log(`[CHAT-DEBUG] Current history count: ${messages.length}`);
// PROCESS MESSAGE FOR AI: Extract files and create concatenated content
const processedMessage = processMessageForAI(message);
const { aiContent, originalContent, fileMetadata } = processedMessage;
// Log file processing details
if (fileMetadata.hasFiles) {
log(`[FILE-PROCESSING] Processed message with ${fileMetadata.fileCount} file(s) and
${fileMetadata.imageCount} image(s)`);
}
// Inject system prompt if this is the first message in the conversation/branch
if (messages.length === 1) {
const currentSettings = getCurrentSettings();
if (currentSettings.enableSystemPrompt && currentSettings.systemPrompt &&
currentSettings.systemPrompt.trim()) {
const systemMessage = {
role: 'system',
content: currentSettings.systemPrompt.trim()
};
// Prepend system prompt to messages array
messages.unshift(systemMessage);
log(`[SYSTEM-PROMPT] Added system prompt to first message in conversation`);
// Save system prompt to database (it becomes part of chat history)
if (chat_id) {
try {
await saveCompleteMessageToDatabase(chat_id, systemMessage);
log(`[SYSTEM-PROMPT] Saved system prompt to chat history`);
} catch (error) {
log(`[SYSTEM-PROMPT] Error saving system prompt to history: ${error.message}`);
}
}
}
}
// Check if we have any messages at all
if (messages.length === 0) {
// No chat_id and no message - this shouldn't happen but handle gracefully
throw new Error('No message provided and no chat history available');
}
// Get available tools
const tools = getAvailableToolsForChat(enabled_tools);
// Call the AI API with tools and capture debug data
const currentSettings = getCurrentSettings();
const debugData = {
requestStart: Date.now(),
endpoint: 'will_be_set_by_adapter',
settings: currentSettings,
toolsEnabled: tools.length
};
// Use provided request ID or generate unique request ID for debug data
const { generateRequestId, initializeToolEvents } = require('./toolEventService');
const requestId = request_id || generateRequestId();
log(`[CHAT] Using request ID: ${requestId} (provided: ${!!request_id})`);
// Initialize tool events for this request
initializeToolEvents(requestId);
await handleChatWithTools(res, messages, tools, chat_id, debugData, 1, requestId, null,
conductor_phase, block_tool_execution, block_recursive_call, user_turn_number);
// Response is handled in handleChatWithTools via streaming
} catch (error) {
log('[CHAT] Error:', error);
// IMPROVED ERROR HANDLING: Save processing error and burn the turn
if (chat_id && user_turn_number) {
const errorMessage = {
role: 'assistant',
content: `Processing error: ${error.message}`,
debug_data: { error: error.message, stack: error.stack }
};
saveCompleteMessageToDatabase(chat_id, errorMessage, null, user_turn_number, 'processing_error')
.then(() => {
incrementTurnNumber(chat_id); // Burn the turn
log(`[ERROR-HANDLING] Saved processing error and burned turn ${user_turn_number}`);
})
.catch(saveError => {
log(`[ERROR-HANDLING] Failed to save processing error: ${saveError.message}`);
});
}
// Only send error response if headers haven't been sent yet
if (!res.headersSent) {
res.status(500).json({ error: error.message });
} else {
// If streaming has started, we can't send JSON, so just end the stream
res.write(`\n[ERROR] ${error.message}`);
res.end();
}
}
}
// ===== TURN VERSIONING SYSTEM =====
// Create a new version for a turn by copying existing messages
async function createTurnVersion(chatId, turnNumber, isRetry = false) {
const { db } = require('../config/database');
try {
db.prepare('BEGIN TRANSACTION').run();
// Get existing messages for this turn AND all previous turns (for complete version 1)
const getMessagesStmt = db.prepare(`
SELECT id, role, content, tool_calls, tool_call_id, tool_name, blocks, debug_data
FROM messages
WHERE chat_id = ? AND turn_number <= ?
ORDER BY timestamp ASC
`);
const messages = getMessagesStmt.all(chatId, turnNumber);
if (messages.length === 0) {
throw new Error(`No messages found for turn ${turnNumber}`);
}
// Get next version number
const getVersionStmt = db.prepare(`
SELECT COALESCE(MAX(version_number), 0) + 1 as next_version
FROM turn_versions
WHERE chat_id = ? AND turn_number = ?
`);
let { next_version } = getVersionStmt.get(chatId, turnNumber) || { next_version: 1 };
// If this is the first version being created, always create version 1 from existing data first
if (next_version === 1) {
// Create version 1 (original)
const insertVersion1Stmt = db.prepare(`
INSERT INTO turn_versions (chat_id, turn_number, version_number, is_active)
VALUES (?, ?, 1, TRUE)
`);
const version1Result = insertVersion1Stmt.run(chatId, turnNumber);
const version1Id = version1Result.lastInsertRowid;
// Copy existing messages to version 1
const insertMessageStmt = db.prepare(`
INSERT INTO message_versions
(turn_version_id, original_message_id, role, content, tool_calls, tool_call_id, tool_name,
blocks, debug_data)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`);
messages.forEach(msg => {
insertMessageStmt.run(
version1Id, msg.id, msg.role, msg.content,
msg.tool_calls, msg.tool_call_id, msg.tool_name, msg.blocks, msg.debug_data
);
});
log(`[VERSIONING] Created version 1 for turn ${turnNumber} with ${messages.length} messages`);
// Now increment version number for the retry
next_version = 2;
log(`[VERSIONING] Incremented next_version to ${next_version} for retry`);
}
// Create new version (for retry)
const insertVersionStmt = db.prepare(`
INSERT INTO turn_versions (chat_id, turn_number, version_number, is_active)
VALUES (?, ?, ?, FALSE)
`);
const versionResult = insertVersionStmt.run(chatId, turnNumber, next_version);
const newVersionId = versionResult.lastInsertRowid;
// For retry, copy all messages from BEFORE this turn (truncate at this point)
if (isRetry) {
// Get all messages from this chat that come BEFORE this turn
const previousMessagesStmt = db.prepare(`
SELECT id, role, content, tool_calls, tool_call_id, tool_name, blocks, debug_data,
turn_number
FROM messages
WHERE chat_id = ? AND turn_number < ?
ORDER BY timestamp ASC
`);
const previousMessages = previousMessagesStmt.all(chatId, turnNumber);
const insertMessageStmt = db.prepare(`
INSERT INTO message_versions
(turn_version_id, original_message_id, role, content, tool_calls, tool_call_id, tool_name,
blocks, debug_data)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`);
// Copy all previous messages to this version (creates truncated history)
previousMessages.forEach(msg => {
insertMessageStmt.run(
newVersionId, msg.id, msg.role, msg.content,
msg.tool_calls, msg.tool_call_id, msg.tool_name, msg.blocks, msg.debug_data
);
});
log(`[VERSIONING] Created retry version ${next_version} for turn ${turnNumber} with
${previousMessages.length} previous messages (truncated history)`);
}
db.prepare('COMMIT').run();
log(`[VERSIONING] Returning version info: versionNumber=${next_version}, turnNumber=${turnNumber}`);
return {
versionId: newVersionId,
versionNumber: next_version,
turnNumber: turnNumber
};
} catch (error) {
try { db.prepare('ROLLBACK').run(); } catch (rollbackErr) { /* ignore */ }
log('[VERSIONING] Error creating turn version:', error);
throw error;
}
}
// Get all versions for a turn
function getTurnVersions(chatId, turnNumber) {
const { db } = require('../config/database');
try {
const stmt = db.prepare(`
SELECT tv.version_number, tv.is_active, tv.created_at,
COUNT(mv.id) as message_count
FROM turn_versions tv
LEFT JOIN message_versions mv ON tv.id = mv.turn_version_id
WHERE tv.chat_id = ? AND tv.turn_number = ?
GROUP BY tv.id, tv.version_number, tv.is_active, tv.created_at
ORDER BY tv.version_number ASC
`);
const versions = stmt.all(chatId, turnNumber);
log(`[VERSIONING] Found ${versions.length} versions for turn ${turnNumber}:`, versions.map(v =>
`v${v.version_number}(active:${v.is_active})`));
return versions;
} catch (error) {
log('[VERSIONING] Error getting turn versions:', error);
return [];
}
}
// Get active version number for a turn
function getActiveTurnVersion(chatId, turnNumber) {
const { db } = require('../config/database');
try {
const stmt = db.prepare(`
SELECT version_number
FROM turn_versions
WHERE chat_id = ? AND turn_number = ? AND is_active = TRUE
`);
const result = stmt.get(chatId, turnNumber);
const activeVersion = result ? result.version_number : 1;
log(`[VERSIONING] Active version for turn ${turnNumber}: ${activeVersion} (found record:
${!!result})`);
return activeVersion;
} catch (error) {
log('[VERSIONING] Error getting active version:', error);
return 1;
}
}
// Set active version for a turn
function setActiveTurnVersion(chatId, turnNumber, versionNumber) {
const { db } = require('../config/database');
try {
db.prepare('BEGIN TRANSACTION').run();
// Deactivate all versions for this turn
const deactivateStmt = db.prepare(`
UPDATE turn_versions
SET is_active = FALSE
WHERE chat_id = ? AND turn_number = ?
`);
deactivateStmt.run(chatId, turnNumber);
// Activate the specified version
const activateStmt = db.prepare(`
UPDATE turn_versions
SET is_active = TRUE
WHERE chat_id = ? AND turn_number = ? AND version_number = ?
`);
const result = activateStmt.run(chatId, turnNumber, versionNumber);
db.prepare('COMMIT').run();
if (result.changes > 0) {
log(`[VERSIONING] Activated version ${versionNumber} for turn ${turnNumber}`);
return true;
} else {
log(`[VERSIONING] Version ${versionNumber} not found for turn ${turnNumber}`);
return false;
}
} catch (error) {
try { db.prepare('ROLLBACK').run(); } catch (rollbackErr) { /* ignore */ }
log('[VERSIONING] Error setting active version:', error);
return false;
}
}
// Save messages to a specific version
async function saveMessagesToVersion(versionId, messages) {
const { db } = require('../config/database');
try {
const insertStmt = db.prepare(`
INSERT INTO message_versions
(turn_version_id, role, content, tool_calls, tool_call_id, tool_name, blocks, debug_data)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`);
messages.forEach(msg => {
insertStmt.run(
versionId, msg.role, msg.content,
msg.tool_calls ? JSON.stringify(msg.tool_calls) : null,
msg.tool_call_id, msg.tool_name,
msg.blocks ? JSON.stringify(msg.blocks) : null,
msg.debug_data ? JSON.stringify(msg.debug_data) : null
);
});
log(`[VERSIONING] Saved ${messages.length} messages to version ${versionId}`);
return true;
} catch (error) {
log('[VERSIONING] Error saving messages to version:', error);
throw error;
}
}
// ===== CHAT BRANCHING FUNCTIONS =====
// Create a new branch from a specific turn point (for retry)
async function createChatBranch(chatId, branchPoint = null) {
const { db } = require('../config/database');
try {
db.prepare('BEGIN TRANSACTION').run();
// Get the next branch name (Branch 1, Branch 2, etc.)
const getBranchCountStmt = db.prepare(`
SELECT COUNT(*) as count
FROM chat_branches
WHERE chat_id = ?
`);
const { count } = getBranchCountStmt.get(chatId) || { count: 0 };
const branchName = count === 0 ? 'main' : `Branch ${count + 1}`;
// Get the currently active branch
const getActiveBranchStmt = db.prepare(`
SELECT id, branch_name
FROM chat_branches
WHERE chat_id = ? AND is_active = TRUE
LIMIT 1
`);
const activeBranch = getActiveBranchStmt.get(chatId);
// Create new branch
const insertBranchStmt = db.prepare(`
INSERT INTO chat_branches (chat_id, branch_name, parent_branch_id, branch_point_turn, is_active)
VALUES (?, ?, ?, ?, ?)
`);
const branchResult = insertBranchStmt.run(
chatId,
branchName,
activeBranch ? activeBranch.id : null,
branchPoint,
count === 0 ? 1 : 0 // First branch (main) should be active (1=TRUE, 0=FALSE)
);
const newBranchId = branchResult.lastInsertRowid;
// Copy messages up to the branch point
let messagesToCopy = [];
if (activeBranch) {
// Get messages from active branch up to branch point
if (branchPoint !== null) {
// Copy messages before the branch point
const getMessagesStmt = db.prepare(`
SELECT original_message_id, role, content, turn_number, tool_calls, tool_call_id,
tool_name, blocks, debug_data, edit_count, edited_at
FROM branch_messages
WHERE branch_id = ? AND turn_number < ?
ORDER BY timestamp ASC
`);
messagesToCopy = getMessagesStmt.all(activeBranch.id, branchPoint);
}
} else {
// No active branch found
if (count === 0) {
// This is normal when creating the very first main branch
log(`[BRANCHING] Creating first main branch for chat ${chatId} - no active branch
expected`);
// No messages to copy for the first branch
} else {
// This shouldn't happen for non-main branches - they should have a parent
log(`[BRANCHING] ERROR: No active branch found for chat ${chatId} when creating branch
${count + 1} - this violates everything-is-a-branch principle`);
throw new Error(`No active branch found for chat ${chatId}. Every chat must have a main
branch before creating additional branches.`);
}
}
// Copy messages to new branch
if (messagesToCopy.length > 0) {
const insertMessageStmt = db.prepare(`
INSERT INTO branch_messages
(branch_id, original_message_id, role, content, turn_number, tool_calls, tool_call_id,
tool_name, blocks, debug_data, edit_count, edited_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`);
messagesToCopy.forEach(msg => {
insertMessageStmt.run(
newBranchId, msg.original_message_id, msg.role, msg.content, msg.turn_number,
msg.tool_calls, msg.tool_call_id, msg.tool_name, msg.blocks, msg.debug_data,
msg.edit_count || 0, msg.edited_at
);
});
}
// CRITICAL FIX: Reset chat turn number to branch point for retry
// This ensures new messages use the retry turn number instead of creating new turns
if (branchPoint !== null) {
const updateTurnStmt = db.prepare(`
UPDATE chats SET turn_number = ? WHERE id = ?
`);
updateTurnStmt.run(branchPoint - 1, chatId); // Set to branchPoint - 1 so next increment makes
it branchPoint
log(`[BRANCHING] Reset chat ${chatId} turn number to ${branchPoint - 1} for retry`);
// CRITICAL FIX #2: Delete any existing messages for the retry turn in the new branch
// This prevents duplicate content when retrying
const deleteRetryTurnStmt = db.prepare(`
DELETE FROM branch_messages
WHERE branch_id = ? AND turn_number >= ?
`);
const deletedCount = deleteRetryTurnStmt.run(newBranchId, branchPoint).changes;
log(`[BRANCHING] Deleted ${deletedCount} existing messages for turn ${branchPoint}+ in new
branch for clean retry`);
}
db.prepare('COMMIT').run();
log(`[BRANCHING] Created branch '${branchName}' for chat ${chatId} with ${messagesToCopy.length}
messages (branch point: ${branchPoint})`);
return {
branchId: newBranchId,
branchName: branchName,
branchPoint: branchPoint
};
} catch (error) {
try { db.prepare('ROLLBACK').run(); } catch (rollbackErr) { /* ignore */ }
log('[BRANCHING] Error creating chat branch:', error);
throw error;
}
}
// Get all branches for a chat
function getChatBranches(chatId) {
const { db } = require('../config/database');
try {
const stmt = db.prepare(`
SELECT cb.id, cb.branch_name, cb.parent_branch_id, cb.branch_point_turn, cb.is_active,
cb.created_at,
COUNT(bm.id) as message_count,
pcb.branch_name as parent_branch_name
FROM chat_branches cb
LEFT JOIN branch_messages bm ON cb.id = bm.branch_id
LEFT JOIN chat_branches pcb ON cb.parent_branch_id = pcb.id
WHERE cb.chat_id = ?
GROUP BY cb.id, cb.branch_name, cb.parent_branch_id, cb.branch_point_turn, cb.is_active,
cb.created_at, pcb.branch_name
ORDER BY cb.created_at ASC
`);
const branches = stmt.all(chatId);
log(`[BRANCHING] Found ${branches.length} branches for chat ${chatId}:`, branches.map(b =>
`${b.branch_name}(active:${b.is_active})`));
return branches;
} catch (error) {
log('[BRANCHING] Error getting chat branches:', error);
return [];
}
}
// Get active branch for a chat
function getActiveChatBranch(chatId) {
const { db } = require('../config/database');
try {
const stmt = db.prepare(`
SELECT id, branch_name
FROM chat_branches
WHERE chat_id = ? AND is_active = TRUE
LIMIT 1
`);
const result = stmt.get(chatId);
if (result) {
log(`[BRANCHING] Active branch for chat ${chatId}: ${result.branch_name}`);
return result;
} else {
log(`[BRANCHING] No active branch found for chat ${chatId}`);
return null;
}
} catch (error) {
log('[BRANCHING] Error getting active branch:', error);
return null;
}
}
// Set active branch for a chat
function setActiveChatBranch(chatId, branchId) {
const { db } = require('../config/database');
try {
db.prepare('BEGIN TRANSACTION').run();
// Deactivate all branches for this chat
const deactivateStmt = db.prepare(`
UPDATE chat_branches
SET is_active = FALSE
WHERE chat_id = ?
`);
deactivateStmt.run(chatId);
// Activate the specified branch
const activateStmt = db.prepare(`
UPDATE chat_branches
SET is_active = TRUE
WHERE id = ? AND chat_id = ?
`);
const result = activateStmt.run(branchId, chatId);
if (result.changes === 0) {
throw new Error(`Branch ${branchId} not found for chat ${chatId}`);
}
db.prepare('COMMIT').run();
// Get branch name for logging
const getBranchStmt = db.prepare(`
SELECT branch_name
FROM chat_branches
WHERE id = ?
`);
const branch = getBranchStmt.get(branchId);
log(`[BRANCHING] Activated branch '${branch?.branch_name}' (${branchId}) for chat ${chatId}`);
return true;
} catch (error) {
try { db.prepare('ROLLBACK').run(); } catch (rollbackErr) { /* ignore */ }
log('[BRANCHING] Error setting active branch:', error);
throw error;
}
}
/**
* Utility function to create file-separated content for saving
* This helps frontends transition to the new structure
* @param {string} userText - User's text input
* @param {Array} files - Array of processed file objects
* @param {Array} images - Array of image objects
* @returns {Object} - { content, originalContent, fileMetadata }
*/
function createMessageWithSeparatedFiles(userText, files = [], images = []) {
const hasFiles = files && files.length > 0;
const hasImages = images && images.length > 0;
let content, originalContent;
if (hasFiles || hasImages) {
// Create multimodal content
originalContent = [];
// Add text part
if (userText || hasFiles) {
originalContent.push({
type: 'text',
text: userText || ''
});
}
// Add images
if (hasImages) {
originalContent.push(...images);
}
// Add files as separate part
if (hasFiles) {
originalContent.push({
type: 'files',
files: files
});
}
// Process for AI (with concatenated content)
const processed = processMessageForAI(originalContent);
content = processed.aiContent;
} else {
// Simple text content
content = userText || '';
originalContent = userText || '';
}
const fileMetadata = {
hasFiles,
fileCount: files.length,
imageCount: images.length,
files: files
};
return {
content,
originalContent,
fileMetadata
};
}
module.exports = {
handleChatWithTools,
processChatRequest,
saveCompleteMessageToDatabase,
updateMessageDebugData,
backend/routes/chat.js:
getChatHistoryForAPI,
getCurrentTurnNumber,
incrementTurnNumber,
// Turn-based debug data functions
saveTurnDebugData,
getTurnDebugData,
getAllTurnDebugData,
// Chat branching functions
createChatBranch,
getChatBranches,
getActiveChatBranch,
setActiveChatBranch,
// File handling functions
extractFilesFromContent,
concatenateFileContent,
createSeparatedFileContent,
processMessageForAI,
createMessageWithSeparatedFiles,
};
// Chat routes - Handle chat operations and messaging
const express = require('express');
const { db } = require('../config/database');
const { processChatRequest, saveTurnDebugData, getTurnDebugData, getAllTurnDebugData, createChatBranch,
getChatBranches, getActiveChatBranch, setActiveChatBranch } = require('../services/chatService');
const { log } = require('../utils/logger');
const router = express.Router();
// Utility function to extract preview text from multimodal content
function extractPreviewText(content) {
if (typeof content === 'string') {
return content;
}
if (Array.isArray(content)) {
// Extract text from multimodal array
const textPart = content.find(part => part.type === 'text');
const filesPart = content.find(part => part.type === 'files');
const imageParts = content.filter(part => part.type === 'image');
// Priority: text content first
if (textPart && textPart.text) {
// If there's text plus other content, show text with indicators
const extras = [];
if (filesPart && filesPart.files && filesPart.files.length > 0) {
if (filesPart.files.length === 1) {
const file = filesPart.files[0];
const fileName = file.fileName || file.name || file.originalName || 'Unknown file';
extras.push(`[File] ${fileName}`);
} else {
extras.push(`[${filesPart.files.length} files]`);
}
}
if (imageParts.length > 0) {
if (imageParts.length === 1) {
extras.push('[Image]');
} else {
extras.push(`[${imageParts.length} images]`);
}
}
if (extras.length > 0) {
return `${textPart.text} + ${extras.join(' + ')}`;
}
return textPart.text;
}
// No text content, show files/images only
else {
const parts = [];
if (filesPart && filesPart.files && filesPart.files.length > 0) {
if (filesPart.files.length === 1) {
const file = filesPart.files[0];
const fileName = file.fileName || file.name || file.originalName || 'Unknown file';
parts.push(`[File] ${fileName}`);
} else {
parts.push(`[${filesPart.files.length} files]`);
}
}
if (imageParts.length > 0) {
if (imageParts.length === 1) {
parts.push('[Image]');
} else {
parts.push(`[${imageParts.length} images]`);
}
}
if (parts.length > 0) {
return parts.join(' + ');
} else {
return '[Multimodal content]';
}
}
}
// Handle any other data types gracefully
if (typeof content === 'object' && content !== null) {
return '[Complex content]';
}
return String(content || '');
}
// Get all chats (everything-is-a-branch system)
router.get('/chats', (req, res) => {
// Get chats with their last message content from active branches
const query = `
SELECT
c.id,
c.title,
c.created_at,
c.updated_at,
COALESCE(bm.content, '') as last_message
FROM chats c
LEFT JOIN chat_branches cb ON c.id = cb.chat_id AND cb.is_active = TRUE
LEFT JOIN (
SELECT
branch_id,
content,
ROW_NUMBER() OVER (PARTITION BY branch_id ORDER BY timestamp DESC) as rn
FROM branch_messages
WHERE role = 'user'
) bm ON cb.id = bm.branch_id AND bm.rn = 1
ORDER BY c.updated_at DESC
`;
try {
const rows = db.prepare(query).all();
log(`[CHATS] Found ${rows ? rows.length : 0} chats:`, rows);
// Transform the data to match frontend expectations
const chats = (rows || []).map(row => {
let processedLastMessage = row.last_message || '';
// Process multimodal content for preview
if (processedLastMessage && (processedLastMessage.startsWith('[') ||
processedLastMessage.startsWith('{'))) {
try {
const parsed = JSON.parse(processedLastMessage);
processedLastMessage = extractPreviewText(parsed);
} catch (e) {
// If parsing fails, keep original
processedLastMessage = row.last_message || '';
}
}
// Convert SQLite timestamp to ISO string for consistent parsing
const timestamp = row.updated_at || row.created_at;
const isoTimestamp = timestamp ? new Date(timestamp + 'Z').toISOString() : new
Date().toISOString();
return {
chat_id: row.id,
title: row.title,
last_message: processedLastMessage,
last_updated: isoTimestamp
};
});
res.json(chats);
} catch (err) {
log('[CHATS] List error:', err);
res.status(500).json({ error: err.message });
}
});
// Create new chat (everything-is-a-branch system)
router.post('/chats', async (req, res) => {
const { chat_id, title } = req.body;
if (!chat_id) {
return res.status(400).json({ error: 'chat_id is required' });
}
try {
// Create chat in chats table
const stmt = db.prepare('INSERT OR REPLACE INTO chats (id, title, created_at, updated_at) VALUES (?,
?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)');
const result = stmt.run(chat_id, title || 'New Chat');
// ALWAYS create a main branch for every new chat (everything-is-a-branch)
const { createChatBranch, setActiveChatBranch } = require('../services/chatService');
// Check if main branch already exists
const existingBranchStmt = db.prepare(`
SELECT id FROM chat_branches
WHERE chat_id = ? AND branch_name = 'main'
`);
const existingBranch = existingBranchStmt.get(chat_id);
if (!existingBranch) {
// Create main branch for this chat
const newBranch = await createChatBranch(chat_id);
await setActiveChatBranch(chat_id, newBranch.branchId);
log(`[CHAT-CREATE] Created main branch for new chat ${chat_id}`);
}
res.json({ success: true, chat_id });
} catch (err) {
log('[CHAT] Create error:', err);
res.status(500).json({ error: err.message });
}
});
// Get chat history including errored messages for UI display
router.get('/chat/:id/history-complete', (req, res) => {
const chatId = req.params.id;
try {
log(`[HISTORY-COMPLETE] Getting complete history including errors for chat ${chatId}`);
// Get the active branch
const activeBranchStmt = db.prepare(`
SELECT id, branch_name
FROM chat_branches
WHERE chat_id = ? AND is_active = TRUE
LIMIT 1
`);
const activeBranch = activeBranchStmt.get(chatId);
if (!activeBranch) {
log(`[HISTORY-COMPLETE] No active branch found for chat ${chatId}`);
return res.json({ messages: [] });
}
// Get ALL messages including errored ones
const messagesStmt = db.prepare(`
SELECT id, original_message_id, role, content, turn_number, tool_calls, tool_call_id, tool_name,
blocks, debug_data, edit_count, edited_at, timestamp, original_content, file_metadata, error_state
FROM branch_messages
WHERE branch_id = ?
ORDER BY timestamp ASC
`);
const branchMessages = messagesStmt.all(activeBranch.id);
const messages = branchMessages.map(row => {
const parsedBlocks = row.blocks ? JSON.parse(row.blocks) : null;
const debugData = row.debug_data ? JSON.parse(row.debug_data) : null;
// Parse file metadata
let originalContent = null;
let fileMetadata = null;
if (row.original_content) {
try {
originalContent = typeof row.original_content === 'string' &&
row.original_content.startsWith('[')
? JSON.parse(row.original_content)
: row.original_content;
} catch (e) {
log(`[HISTORY-COMPLETE] Error parsing original_content: ${e.message}`);
}
}
if (row.file_metadata) {
try {
fileMetadata = JSON.parse(row.file_metadata);
} catch (e) {
log(`[HISTORY-COMPLETE] Error parsing file_metadata: ${e.message}`);
}
}
// Parse content
let parsedContent = row.content;
if (typeof row.content === 'string' && row.content.startsWith('[')) {
try {
parsedContent = JSON.parse(row.content);
} catch (e) {
parsedContent = row.content;
}
}
const message = {
id: row.original_message_id || row.id,
role: row.role,
content: parsedContent,
timestamp: row.timestamp,
turn_number: row.turn_number,
edit_count: row.edit_count || 0,
edited_at: row.edited_at,
debug_data: debugData,
blocks: parsedBlocks,
error_state: row.error_state // Include error state for UI
};
// Add file handling fields if present
if (originalContent !== null) {
message.original_content = originalContent;
}
if (fileMetadata !== null) {
message.file_metadata = fileMetadata;
}
// Add tool data if present
if (row.tool_calls) {
try {
message.tool_calls = JSON.parse(row.tool_calls);
} catch (e) {
log(`[HISTORY-COMPLETE] Error parsing tool_calls: ${e.message}`);
}
}
if (row.tool_call_id) {
message.tool_call_id = row.tool_call_id;
}
if (row.tool_name) {
message.tool_name = row.tool_name;
}
return message;
});
log(`[HISTORY-COMPLETE] Retrieved ${messages.length} messages (including errors) from branch
'${activeBranch.branch_name}'`);
res.json({ messages });
} catch (err) {
log('[HISTORY-COMPLETE] Error:', err);
res.status(500).json({ error: err.message });
}
});
// Get chat history (everything-is-a-branch system) - FILTERED for AI
router.get('/chat/:id/history', (req, res) => {
const chatId = req.params.id;
try {
// Everything-is-a-branch: Always use active branch
log(`[HISTORY] Getting history from active branch for chat ${chatId}`);
// Get the active branch
const activeBranchStmt = db.prepare(`
SELECT id, branch_name
FROM chat_branches
WHERE chat_id = ? AND is_active = TRUE
LIMIT 1
`);
const activeBranch = activeBranchStmt.get(chatId);
if (!activeBranch) {
log(`[HISTORY] No active branch found for chat ${chatId} - this shouldn't happen in everythingis-a-branch system`);
return res.json({ messages: [] });
}
// Get all messages from the active branch (including new file handling fields)
const messagesStmt = db.prepare(`
SELECT id, original_message_id, role, content, turn_number, tool_calls, tool_call_id, tool_name,
blocks, debug_data, edit_count, edited_at, timestamp, original_content, file_metadata
FROM branch_messages
WHERE branch_id = ?
ORDER BY timestamp ASC
`);
const branchMessages = messagesStmt.all(activeBranch.id);
const messages = branchMessages.map(row => {
const parsedBlocks = row.blocks ? JSON.parse(row.blocks) : null;
const debugData = row.debug_data ? JSON.parse(row.debug_data) : null;
// Parse new file handling fields
let originalContent = null;
let fileMetadata = null;
if (row.original_content) {
try {
originalContent = typeof row.original_content === 'string' &&
row.original_content.startsWith('[')
? JSON.parse(row.original_content)
: row.original_content;
} catch (e) {
log(`[HISTORY] Error parsing original_content: ${e.message}`);
}
}
if (row.file_metadata) {
try {
fileMetadata = JSON.parse(row.file_metadata);
} catch (e) {
log(`[HISTORY] Error parsing file_metadata: ${e.message}`);
}
}
// Parse content - handle both string and JSON (multimodal) content
let parsedContent = row.content;
if (typeof row.content === 'string' && row.content.startsWith('[')) {
try {
// Try to parse as JSON array (multimodal content)
parsedContent = JSON.parse(row.content);
} catch (e) {
// If parsing fails, keep as string
parsedContent = row.content;
}
}
log(`[HISTORY] Loading blocks for ${row.role} message in turn ${row.turn_number}:`, parsedBlocks
? parsedBlocks.map(b => ({ type: b.type, id: b.id })) : 'null');
const message = {
id: row.original_message_id || row.id, // Use original ID if available for editing
compatibility
role: row.role,
content: parsedContent,
timestamp: row.timestamp,
turn_number: row.turn_number,
edit_count: row.edit_count || 0,
edited_at: row.edited_at,
debug_data: debugData,
blocks: parsedBlocks
};
// Add new file handling fields if present
if (originalContent !== null) {
message.original_content = originalContent;
}
if (fileMetadata !== null) {
message.file_metadata = fileMetadata;
}
// Add tool data if present
if (row.tool_calls) {
try {
message.tool_calls = JSON.parse(row.tool_calls);
} catch (e) {
log(`[HISTORY] Error parsing tool_calls: ${e.message}`);
}
}
if (row.tool_call_id) {
message.tool_call_id = row.tool_call_id;
}
if (row.tool_name) {
message.tool_name = row.tool_name;
}
return message;
});
log(`[HISTORY] Retrieved ${messages.length} successful messages from branch
'${activeBranch.branch_name}' (errors filtered out)`);
res.json({ messages });
} catch (err) {
log('[HISTORY] Error:', err);
res.status(500).json({ error: err.message });
}
});
// Delete chat
router.delete('/chat/:id', (req, res) => {
const chatId = req.params.id;
try {
// Begin transaction
db.prepare('BEGIN TRANSACTION').run();
// Everything-is-a-branch: Delete all branch messages and branches for this chat
// First delete all branch messages
const deleteBranchMessages = db.prepare(`
DELETE FROM branch_messages
WHERE branch_id IN (SELECT id FROM chat_branches WHERE chat_id = ?)
`);
deleteBranchMessages.run(chatId);
// Then delete all branches for this chat
const deleteBranches = db.prepare('DELETE FROM chat_branches WHERE chat_id = ?');
deleteBranches.run(chatId);
// Finally delete the chat itself
const deleteChat = db.prepare('DELETE FROM chats WHERE id = ?');
deleteChat.run(chatId);
// Commit transaction
db.prepare('COMMIT').run();
log(`[CHAT] Deleted chat: ${chatId}`);
res.json({ success: true });
} catch (err) {
// Rollback on error
try { db.prepare('ROLLBACK').run(); } catch (rollbackErr) { /* ignore */ }
log('[CHAT] Error deleting chat:', err);
res.status(500).json({ error: err.message });
}
});
// Save message using unified approach
router.post('/message', async (req, res) => {
try {
const { chat_id, role, content, turn_number, blocks, tool_calls, tool_call_id, tool_name,
original_content, file_metadata } = req.body;
if (!chat_id || !role || content === null || content === undefined) {
return res.status(400).json({ error: 'chat_id, role, and content are required' });
}
// Create complete message structure with all possible fields
const completeMessage = {
role: role,
content: content
};
// Add tool-specific fields if present
if (tool_calls) completeMessage.tool_calls = tool_calls;
if (tool_call_id) completeMessage.tool_call_id = tool_call_id;
if (tool_name) completeMessage.tool_name = tool_name;
// Add new file handling fields if present
if (original_content !== undefined) completeMessage.originalContent = original_content;
if (file_metadata !== undefined) completeMessage.fileMetadata = file_metadata;
// Use the unified save function
const { saveCompleteMessageToDatabase, incrementTurnNumber } = require('../services/chatService');
// Use turn number provided by frontend
await saveCompleteMessageToDatabase(chat_id, completeMessage, blocks, turn_number);
// Increment turn number when user sends a message (starts new conversation turn)
if (role === 'user') {
incrementTurnNumber(chat_id);
}
res.json({ success: true });
} catch (error) {
log('[MESSAGE] Error:', error);
res.status(500).json({ error: error.message });
}
});
// Update chat title
router.patch('/chat/:id/title', (req, res) => {
const chatId = req.params.id;
const { title } = req.body;
if (!title) {
return res.status(400).json({ error: 'title is required' });
}
try {
const stmt = db.prepare('UPDATE chats SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?');
const result = stmt.run(title, chatId);
if (result.changes === 0) {
return res.status(404).json({ error: 'Chat not found' });
}
log(`[CHAT] Updated title for chat ${chatId} to "${title}"`);
res.json({ success: true, chat_id: chatId, title: title });
} catch (err) {
log('[CHAT] Error updating title:', err);
res.status(500).json({ error: err.message });
}
});
// Get clean chat history in API format (for user debug panels)
router.get('/chat/:id/api-history', (req, res) => {
const chatId = req.params.id;
try {
const { getChatHistoryForAPI } = require('../services/chatService');
const apiHistory = getChatHistoryForAPI(chatId);
res.json(apiHistory);
} catch (err) {
log('[API-HISTORY] Error:', err);
res.status(500).json({ error: err.message });
}
});
// Get current turn number for a chat
router.get('/chat/:id/current-turn', (req, res) => {
const { id: chatId } = req.params;
try {
const { getCurrentTurnNumber } = require('../services/chatService');
const turnNumber = getCurrentTurnNumber(chatId);
res.json({ turn_number: turnNumber });
} catch (err) {
log('[CURRENT-TURN] Error:', err);
res.status(500).json({ error: err.message });
}
});
// Update debug data for a message
router.patch('/message/debug', async (req, res) => {
try {
const { chat_id, role, turn_number, debug_data } = req.body;
if (!chat_id || !role || !turn_number) {
return res.status(400).json({ error: 'chat_id, role, and turn_number are required' });
}
const { updateMessageDebugData } = require('../services/chatService');
await updateMessageDebugData(chat_id, role, turn_number, debug_data);
res.json({ success: true });
} catch (error) {
log('[UPDATE-DEBUG] Error:', error);
res.status(500).json({ error: error.message });
}
});
// Turn data endpoints (RESTful design)
// Save turn data
router.post('/chat/:id/turns/:turnNumber', async (req, res) => {
try {
const { id: chatId, turnNumber } = req.params;
const { data } = req.body;
const turnNum = parseInt(turnNumber, 10);
if (isNaN(turnNum)) {
return res.status(400).json({ error: 'Invalid turn number' });
}
if (!data) {
return res.status(400).json({ error: 'data is required' });
}
await saveTurnDebugData(chatId, turnNum, data);
res.json({ success: true });
} catch (error) {
log('[TURN-DATA-SAVE] Error:', error);
res.status(500).json({ error: error.message });
}
});
// Get turn data
router.get('/chat/:id/turns/:turnNumber', (req, res) => {
try {
const { id: chatId, turnNumber } = req.params;
const turnNum = parseInt(turnNumber, 10);
if (isNaN(turnNum)) {
return res.status(400).json({ error: 'Invalid turn number' });
}
const turnData = getTurnDebugData(chatId, turnNum);
if (turnData) {
res.json(turnData);
} else {
res.status(404).json({ error: 'Turn data not found' });
}
} catch (error) {
log('[TURN-DATA-GET] Error:', error);
res.status(500).json({ error: error.message });
}
});
// Get messages for a specific turn
router.get('/chat/:id/turn/:turnNumber', (req, res) => {
try {
const { id: chatId, turnNumber } = req.params;
const turnNum = parseInt(turnNumber, 10);
if (isNaN(turnNum)) {
return res.status(400).json({ error: 'Invalid turn number' });
}
// Get all messages for this turn from the current active branch
// First, get the active branch for this chat
const activeBranchStmt = db.prepare(`
SELECT id FROM chat_branches
WHERE chat_id = ? AND is_active = TRUE
LIMIT 1
`);
const activeBranch = activeBranchStmt.get(chatId);
let messages = [];
if (activeBranch) {
// Get messages from the active branch
log(`[TURN-MESSAGES] Getting messages from active branch ${activeBranch.id} for turn
${turnNum}`);
const stmt = db.prepare(`
SELECT id, role, content, timestamp, blocks, turn_number,
edit_count, edited_at
FROM branch_messages
WHERE branch_id = ? AND turn_number = ?
ORDER BY timestamp ASC
`);
messages = stmt.all(activeBranch.id, turnNum);
} else {
// Everything-is-a-branch: No active branch should never happen
log(`[TURN-MESSAGES] ERROR: No active branch found for chat ${chatId} - this violates
everything-is-a-branch principle`);
return res.status(500).json({ error: `No active branch found for chat ${chatId}. Every chat must
have a main branch.` });
}
log(`[TURN-MESSAGES] Found ${messages.length} messages for turn ${turnNum} in chat ${chatId}`);
// Parse blocks for each message and handle multimodal content
const processedMessages = messages.map(msg => {
let processedContent = msg.content;
// Parse JSON stringified multimodal content
if (typeof msg.content === 'string' && msg.content.startsWith('[')) {
try {
processedContent = JSON.parse(msg.content);
} catch (e) {
// If parsing fails, keep as string
processedContent = msg.content;
}
}
return {
...msg,
content: processedContent,
blocks: msg.blocks ? JSON.parse(msg.blocks) : null,
edit_count: msg.edit_count || 0
};
});
res.json({ messages: processedMessages });
} catch (error) {
log('[TURN-MESSAGES] Error:', error);
res.status(500).json({ error: error.message });
}
});
// Get all turn data for a chat
router.get('/chat/:id/turns', (req, res) => {
try {
const { id: chatId } = req.params;
const turnDataMap = getAllTurnDebugData(chatId);
res.json(turnDataMap);
} catch (error) {
log('[ALL-TURN-DATA] Error:', error);
res.status(500).json({ error: error.message });
}
});
// Main chat endpoint that frontend expects
router.post('/chat', processChatRequest);
// ===== TURN VERSIONING ENDPOINTS =====
// Create new branch for retry from a specific turn
router.post('/chat/:id/turn/:turnNumber/retry', async (req, res) => {
try {
const { id: chatId, turnNumber } = req.params;
const turnNum = parseInt(turnNumber, 10);
if (isNaN(turnNum)) {
return res.status(400).json({ error: 'Invalid turn number' });
}
const branchInfo = await createChatBranch(chatId, turnNum);
// Set the new branch as active
await setActiveChatBranch(chatId, branchInfo.branchId);
res.json({
success: true,
branchId: branchInfo.branchId,
branchName: branchInfo.branchName,
branchPoint: branchInfo.branchPoint
});
} catch (error) {
log('[RETRY] Error:', error);
res.status(500).json({ error: error.message });
}
});
// Get all branches for a chat
router.get('/chat/:id/branches', (req, res) => {
try {
const { id: chatId } = req.params;
const branches = getChatBranches(chatId);
const activeBranch = getActiveChatBranch(chatId);
const responseData = {
branches,
activeBranch,
totalBranches: branches.length
};
log(`[BRANCHES] API response for chat ${chatId}: activeBranch=${activeBranch?.branch_name},
totalBranches=${branches.length}`);
res.json(responseData);
} catch (error) {
log('[BRANCHES] Error:', error);
res.status(500).json({ error: error.message });
}
});
// Switch to a specific branch
router.post('/chat/:id/branch/:branchId/activate', (req, res) => {
try {
const { id: chatId, branchId } = req.params;
const branchIdNum = parseInt(branchId, 10);
if (isNaN(branchIdNum)) {
return res.status(400).json({ error: 'Invalid branch ID' });
}
const success = setActiveChatBranch(chatId, branchIdNum);
if (success) {
res.json({ success: true });
} else {
res.status(404).json({ error: 'Branch not found' });
}
} catch (error) {
log('[ACTIVATE-BRANCH] Error:', error);
res.status(500).json({ error: error.message });
}
});
module.exports = router;
// Edit message content
router.patch('/message/:id', async (req, res) => {
try {
const messageId = parseInt(req.params.id, 10);
const { content, original_content, file_metadata } = req.body;
if (isNaN(messageId)) {
return res.status(400).json({ error: 'Invalid message ID' });
}
if (!content || (typeof content === 'string' && content.trim() === '')) {
return res.status(400).json({ error: 'Content is required' });
}
// Try to find the message in branch_messages first (for branching system)
let currentMessage = null;
let isInBranch = false;
// First, try to find in branch_messages table
const getBranchMessageStmt = db.prepare(`
SELECT content, edit_count, edited_at, branch_id
FROM branch_messages
WHERE id = ?
`);
currentMessage = getBranchMessageStmt.get(messageId);
if (currentMessage) {
isInBranch = true;
log(`[EDIT] Found message ${messageId} in branch_messages table`);
} else {
// Everything-is-a-branch: All messages should be in branch_messages
log(`[EDIT] Message ${messageId} not found in branch_messages - this shouldn't happen in
everything-is-a-branch system`);
}
if (!currentMessage) {
return res.status(404).json({ error: 'Message not found' });
}
const newEditCount = (currentMessage.edit_count || 0) + 1;
let result;
if (isInBranch) {
// Update message in branch_messages table (no original_content column here)
log(`[EDIT] Updating message ${messageId} in branch_messages table`);
const updateBranchStmt = db.prepare(`
UPDATE branch_messages
SET content = ?,
original_content = ?,
file_metadata = ?,
edit_count = ?,
edited_at = CURRENT_TIMESTAMP
WHERE id = ?
`);
result = updateBranchStmt.run(
Array.isArray(content) ? JSON.stringify(content) : content,
original_content ? JSON.stringify(original_content) : null,
file_metadata ? JSON.stringify(file_metadata) : null,
newEditCount,
messageId
);
} else {
// Update message in original messages table (has original_content column)
log(`[EDIT] Updating message ${messageId} in original messages table`);
const originalContent = currentMessage.original_content || currentMessage.content;
const updateOriginalStmt = db.prepare(`
UPDATE messages
SET content = ?,
original_content = ?,
edit_count = ?,
edited_at = CURRENT_TIMESTAMP
WHERE id = ?
`);
result = updateOriginalStmt.run(
Array.isArray(content) ? JSON.stringify(content) : content,
originalContent,
newEditCount,
messageId
);
}
if (result.changes === 0) {
return res.status(404).json({ error: 'Message not found' });
}
log(`[EDIT] Updated message ${messageId}, edit count: ${newEditCount}`);
res.json({
success: true,
message_id: messageId,
edit_count: newEditCount,
edited_at: new Date().toISOString()
});
} catch (error) {
log('[EDIT] Error updating message:', error);
res.status(500).json({ error: error.message });
}
});
// Get message by ID for editing
router.get('/message/:id', (req, res) => {
try {
const messageId = parseInt(req.params.id, 10);
if (isNaN(messageId)) {
return res.status(400).json({ error: 'Invalid message ID' });
}
const stmt = db.prepare(`
SELECT id, chat_id, role, content, original_content,
edit_count, edited_at, timestamp, turn_number
FROM messages WHERE id = ?
`);
const message = stmt.get(messageId);
backend/adapters/ResponseAdapterFactory.js:
if (!message) {
return res.status(404).json({ error: 'Message not found' });
}
res.json(message);
} catch (error) {
log('[GET-MESSAGE] Error:', error);
res.status(500).json({ error: error.message });
}
});
/**
* Response Adapter Factory
*
* Factory that creates the appropriate response adapter based on settings.
* This is the main entry point for the adapter system.
*/
const OpenAIAdapter = require('./OpenAIAdapter');
const GoogleAdapter = require('./GoogleAdapter');
const AnthropicAdapter = require('./AnthropicAdapter');
class ResponseAdapterFactory {
constructor() {
// Register available adapters
this.adapters = [
new AnthropicAdapter(),
new GoogleAdapter(),
new OpenAIAdapter() // OpenAI as fallback
];
}
/**
* Get the appropriate adapter for the given settings
* @param {Object} settings - Current API settings
* @returns {BaseResponseAdapter} The adapter to use
*/
getAdapter(settings) {
// Find the first adapter that can handle these settings
for (const adapter of this.adapters) {
if (adapter.canHandle(settings)) {
return adapter;
}
}
// Fallback to OpenAI adapter
return this.adapters[this.adapters.length - 1];
}
/**
* Create a unified request object
* @param {Array} messages - Chat messages
* @param {Array} tools - Available tools
* @param {string} model - Model name
* @returns {Object} Unified request format
*/
createUnifiedRequest(messages, tools, model) {
return {
backend/adapters/OpenAIAdapter.js:
model: model,
messages: messages,
tools: tools || [],
stream: true
};
}
/**
* Register a new adapter
* @param {BaseResponseAdapter} adapter - Adapter to register
*/
registerAdapter(adapter) {
this.adapters.unshift(adapter); // Add to beginning for priority
}
/**
* Get all registered adapters
* @returns {Array} Array of adapters
*/
getAvailableAdapters() {
return [...this.adapters];
}
}
// Export singleton instance
module.exports = new ResponseAdapterFactory();
/**
* OpenAI Response Adapter
*
* Handles OpenAI API responses and converts them to unified format
*/
const BaseResponseAdapter = require('./BaseResponseAdapter');
const UnifiedResponse = require('./UnifiedResponse');
class OpenAIAdapter extends BaseResponseAdapter {
constructor() {
super('openai');
}
canHandle(settings) {
return !settings.apiUrl.toLowerCase().includes('google') &&
!settings.apiUrl.toLowerCase().includes('anthropic.com');
}
getEndpointUrl(settings) {
return `${settings.apiUrl}/chat/completions`;
}
getHeaders(settings) {
const headers = super.getHeaders(settings);
if (settings.apiKey) {
headers['Authorization'] = `Bearer ${settings.apiKey}`;
}
// OpenRouter-specific headers
if (settings.apiUrl.includes('openrouter.ai')) {
headers['HTTP-Referer'] = 'https://simplechatjs.local';
headers['X-Title'] = 'SimpleChatJS';
}
return headers;
}
convertRequest(unifiedRequest) {
// Process messages to handle multimodal content
const processedMessages = unifiedRequest.messages.map(message => {
return {
role: message.role,
content: this.convertContentToOpenAI(message.content),
// Preserve tool calls if present
...(message.tool_calls ? { tool_calls: message.tool_calls } : {}),
// Preserve tool call id if present
...(message.tool_call_id ? { tool_call_id: message.tool_call_id } : {}),
// Preserve tool name if present
...(message.tool_name ? { tool_name: message.tool_name } : {})
};
});
return {
model: unifiedRequest.model,
messages: processedMessages,
stream: true,
...(unifiedRequest.tools?.length ? { tools: unifiedRequest.tools } : {})
};
}
processChunk(chunk, response, context) {
const events = [];
try {
const lines = chunk.toString().split('\n');
for (const line of lines) {
if (line.startsWith('data: ')) {
const dataStr = line.slice(6);
if (dataStr === '[DONE]') {
response.setComplete(true);
continue;
}
try {
const data = JSON.parse(dataStr);
const delta = data.choices?.[0]?.delta;
if (!delta) continue;
// Handle content
if (delta.content) {
response.addContent(delta.content);
}
// Handle tool calls
if (delta.tool_calls) {
for (const toolCall of delta.tool_calls) {
if (toolCall.index === 0 && toolCall.id) {
// New tool call
const newToolCall = {
id: toolCall.id,
type: 'function',
function: {
name: toolCall.function?.name || '',
arguments: toolCall.function?.arguments || ''
}
};
response.addToolCall(newToolCall);
context.currentToolCall = newToolCall;
// Emit tool call detected event
events.push({
type: 'tool_call_detected',
data: {
toolName: newToolCall.function.name,
toolId: newToolCall.id
}
});
} else if (context.currentToolCall && toolCall.function?.arguments) {
// Continue building arguments
context.currentToolCall.function.arguments +=
toolCall.function.arguments;
// Update the tool call in response
const latestToolCall = response.getLatestToolCall();
if (latestToolCall) {
latestToolCall.function.arguments =
context.currentToolCall.function.arguments;
}
}
}
}
// Handle usage info
if (data.usage) {
response.setUsage(data.usage);
}
} catch (parseError) {
// Skip invalid JSON lines
continue;
}
}
}
} catch (error) {
console.error('[OPENAI-ADAPTER] Error processing chunk:', error);
}
return { events, context };
}
/**
* Convert content (string or multimodal array) to OpenAI format
* @param {string|Array} content - Message content
* @returns {string|Array} Content in OpenAI format
*/
convertContentToOpenAI(content) {
// If content is a string (text-only), return as-is
if (typeof content === 'string') {
return content;
}
backend/adapters/GoogleAdapter.js:
// If content is an array (multimodal), convert each part
if (Array.isArray(content)) {
return content.map(part => {
switch (part.type) {
case 'text':
return {
type: 'text',
text: part.text
};
case 'image':
// Convert to OpenAI's image_url format with data URL
// HACK: Ollama/OpenAI-compatible APIs often support WebP data but expect JPEG/PNG
MIME types
let mimeType = part.mimeType || 'image/jpeg';
if (mimeType === 'image/webp') {
mimeType = 'image/jpeg'; // Lie about WebP being JPEG for compatibility
}
const dataUrl = `data:${mimeType};base64,${part.imageData}`;
return {
type: 'image_url',
image_url: {
url: dataUrl
}
};
default:
// Fallback for unknown types
console.warn(`[OPENAI-ADAPTER] Unknown content part type: ${part.type}`);
return {
type: 'text',
text: part.text || JSON.stringify(part)
};
}
});
}
// Fallback for unexpected content format
console.warn(`[OPENAI-ADAPTER] Unexpected content format:`, typeof content);
return String(content);
}
/**
* Check if a model supports vision/image input
* Since OpenAI could be any model/provider, we'll assume vision support
* and let the API handle unsupported models
*/
supportsVision(modelName) {
// For OpenAI adapter, we can't reliably detect vision support
// since it could be any model (local, OpenAI, compatible APIs)
// So we return true and let the API handle unsupported models
return true;
}
}
module.exports = OpenAIAdapter;
/**
* Google/Gemini Response Adapter
*
* Handles Google Gemini API responses and converts them to unified format
*/
const BaseResponseAdapter = require('./BaseResponseAdapter');
const UnifiedResponse = require('./UnifiedResponse');
class GoogleAdapter extends BaseResponseAdapter {
constructor() {
super('google');
}
canHandle(settings) {
return settings.apiUrl.toLowerCase().includes('google');
}
getEndpointUrl(settings) {
const cleanModelName = settings.modelName.startsWith('models/')
? settings.modelName.substring(7)
: settings.modelName;
return `${settings.apiUrl}/models/${cleanModelName}:streamGenerateContent?key=${settings.apiKey}`;
}
convertRequest(unifiedRequest) {
// Convert OpenAI format to Gemini format
const contents = [];
for (const msg of unifiedRequest.messages) {
// Skip system messages - they're handled via systemInstruction
if (msg.role === 'system') {
continue;
}
// Check if message is already in Gemini format
if (msg.parts) {
contents.push(msg);
} else if (msg.role === 'user' || msg.role === 'assistant') {
// Convert content to parts array
const parts = this.convertContentToParts(msg.content);
contents.push({
role: msg.role === 'assistant' ? 'model' : 'user',
parts: parts
});
} else if (msg.role === 'tool') {
// OpenAI tool response format - convert to Gemini
let responseContent;
try {
// Parse JSON string to object for Gemini
responseContent = JSON.parse(msg.content);
} catch (e) {
// If not JSON, use as-is
responseContent = { result: msg.content };
}
contents.push({
role: 'user',
parts: [{
functionResponse: {
name: msg.tool_name || 'unknown_tool',
response: responseContent
}
}]
});
}
}
// Convert tools format
let geminiTools = [];
if (unifiedRequest.tools?.length > 0) {
const functionDeclarations = unifiedRequest.tools.map(tool => {
const cleanParameters = this.cleanSchemaForGemini(tool.function.parameters);
return {
name: tool.function.name,
description: tool.function.description,
parameters: cleanParameters
};
});
geminiTools = [{ functionDeclarations }];
}
// Add thinking mode for supported models
const modelSupportsThinking = this.supportsThinking(unifiedRequest.model);
const thinkingEnabled = this.isThinkingEnabled();
const thinkingBudget = this.getThinkingBudget();
const request = {
contents,
...(geminiTools.length > 0 ? { tools: geminiTools } : {})
};
// Add thinking configuration for supported models
if (modelSupportsThinking && thinkingEnabled && thinkingBudget !== 0) {
request.generationConfig = {
thinkingConfig: {
includeThoughts: true
}
};
// Only set thinkingBudget if it's not -1 (auto mode)
if (thinkingBudget !== -1) {
request.generationConfig.thinkingConfig.thinkingBudget = thinkingBudget;
}
}
// Add system instruction if present
const systemMessage = unifiedRequest.messages.find(msg => msg.role === 'system');
if (systemMessage) {
request.systemInstruction = {
parts: [{ text: systemMessage.content }]
};
}
return request;
}
processChunk(chunk, response, context) {
const events = [];
try {
context.buffer += chunk.toString();
// Google sends streaming JSON in various formats - handle them all
let remainingBuffer = context.buffer;
let processedAny = false;
// Keep trying to parse complete JSON chunks from the buffer
while (remainingBuffer.trim()) {
let parsed;
let jsonEndIndex = -1;
try {
// Find complete JSON boundaries (objects or arrays)
let bracketCount = 0;
let inString = false;
let escaping = false;
let foundStart = false;
for (let i = 0; i < remainingBuffer.length; i++) {
const char = remainingBuffer[i];
if (escaping) {
escaping = false;
continue;
}
if (char === '\\') {
escaping = true;
continue;
}
if (char === '"') {
inString = !inString;
continue;
}
if (!inString) {
if (char === '[' || char === '{') {
bracketCount++;
foundStart = true;
} else if (char === ']' || char === '}') {
bracketCount--;
if (bracketCount === 0 && foundStart) {
jsonEndIndex = i + 1;
break;
}
}
}
}
if (jsonEndIndex === -1) {
break; // Wait for more data
}
const jsonString = remainingBuffer.substring(0, jsonEndIndex).trim();
parsed = JSON.parse(jsonString);
// Update remaining buffer
remainingBuffer = remainingBuffer.substring(jsonEndIndex).trim();
remainingBuffer = remainingBuffer.replace(/^[,\s]+/, '');
} catch (parseError) {
break; // Wait for more data
}
// Process each response immediately for proper streaming
const responses = Array.isArray(parsed) ? parsed : [parsed];
// Process each response object normally for streaming
for (const responseObj of responses) {
const candidate = responseObj.candidates?.[0];
if (!candidate) continue;
const parts = candidate.content?.parts || [];
// Handle thinking mode for Google models
const isThinkingModel = this.supportsThinking(context.model || '');
const isThinkingEnabled = this.isThinkingEnabled();
const thinkingBudget = this.getThinkingBudget();
const hasThoughts = parts.some(part => part.thought);
if (isThinkingModel && isThinkingEnabled && thinkingBudget !== 0) {
// Use thinking mode processing if thinking is enabled for this model
// This handles both chunks with thoughts AND regular text in thinking conversations
// Process each part according to Google's format
for (const part of parts) {
// Handle text content (thinking or regular)
if (part.text) {
// If this part has thought=true, it's thinking content
if (part.thought) {
// Parse Gemini thinking content to separate summary from detailed
thoughts
const lines = part.text.split('\n');
const summaryLine = lines[0] || ''; // "**Summary Title**"
const summary = summaryLine.replace(/\*\*/g, '').trim(); // Remove
markdown bold
const detailedThoughts = lines.slice(2).join('\n').trim(); // Skip title
and empty line
// Use summary as dropdown title, detailed thoughts as content
if (summary && detailedThoughts) {
response.addContent(`<thinking title="${summary}">`);
response.addContent(detailedThoughts);
response.addContent('</thinking>');
response.addDebugData('thinkingContent', detailedThoughts);
response.addDebugData('thinkingSummary', summary);
} else {
// Fallback: use original format if parsing fails
response.addContent('<thinking>');
response.addContent(part.text);
response.addContent('</thinking>');
response.addDebugData('thinkingContent', part.text);
}
}
// Otherwise it's the regular response
else {
response.addContent(part.text);
}
}
// Handle function calls (can exist with or without text)
if (part.functionCall) {
const toolCall = {
id: `call_${Date.now()}_${response.toolCalls.length}`,
type: 'function',
function: {
name: part.functionCall.name,
arguments: JSON.stringify(part.functionCall.args || {})
}
};
response.addToolCall(toolCall);
events.push({
type: 'tool_call_detected',
data: {
toolName: toolCall.function.name,
toolId: toolCall.id
}
});
}
}
} else {
// Process all parts normally
for (const part of parts) {
// Handle text content
if (part.text) {
response.addContent(part.text);
}
// Handle function calls
if (part.functionCall) {
const toolCall = {
id: `call_${Date.now()}_${response.toolCalls.length}`,
type: 'function',
function: {
name: part.functionCall.name,
arguments: JSON.stringify(part.functionCall.args || {})
}
};
response.addToolCall(toolCall);
// Emit tool call detected event
events.push({
type: 'tool_call_detected',
data: {
toolName: toolCall.function.name,
toolId: toolCall.id
}
});
}
}
}
// Handle finish reason
if (candidate.finishReason === 'STOP') {
response.setComplete(true);
}
// Handle usage metadata
if (responseObj.usageMetadata) {
response.setUsage({
prompt_tokens: responseObj.usageMetadata.promptTokenCount,
completion_tokens: responseObj.usageMetadata.candidatesTokenCount,
total_tokens: responseObj.usageMetadata.totalTokenCount
});
}
}
processedAny = true;
}
// Update buffer with remaining unparsed content
if (processedAny) {
context.buffer = remainingBuffer;
}
} catch (error) {
// If any error occurs (parsing, processing, etc.), log and continue
console.error('[GOOGLE-ADAPTER] Error processing chunk:', error.message);
// Reset buffer if it gets too large to prevent memory issues
if (context.buffer.length > 10000) {
context.buffer = '';
}
}
return { events, context };
}
createContext(modelName = '') {
return {
buffer: '', // Gemini needs buffering for complete JSON parsing
currentToolCall: null,
processingState: 'content',
model: modelName // Store model name for thinking detection
};
}
/**
* Convert content (string or array) to Google Gemini parts format
* @param {string|Array} content - Message content
* @returns {Array} Array of parts for Gemini API
*/
convertContentToParts(content) {
// If content is a string (current format), convert to text part
if (typeof content === 'string') {
return [{ text: content }];
}
// If content is an array (new multimodal format), convert each part
if (Array.isArray(content)) {
return content.map(part => {
switch (part.type) {
case 'text':
return { text: part.text };
case 'image':
// Convert to Google's inlineData format
return {
inlineData: {
mimeType: part.mimeType || 'image/jpeg',
data: part.imageData
}
};
default:
// Fallback for unknown types
console.warn(`[GOOGLE-ADAPTER] Unknown content part type: ${part.type}`);
return { text: part.text || JSON.stringify(part) };
}
});
}
// Fallback for unexpected content format
console.warn(`[GOOGLE-ADAPTER] Unexpected content format:`, typeof content);
return [{ text: String(content) }];
}
/**
* Clean schema for Gemini compatibility
* Removes fields that Gemini doesn't support
*/
cleanSchemaForGemini(schema) {
if (!schema || typeof schema !== 'object') return schema;
const cleaned = {};
for (const [key, value] of Object.entries(schema)) {
// Skip fields Gemini doesn't support
if (key === 'additionalProperties' || key === 'default') {
continue;
}
// Recursively clean nested objects and arrays
if (typeof value === 'object' && value !== null) {
if (Array.isArray(value)) {
cleaned[key] = value.map(item =>
typeof item === 'object' ? this.cleanSchemaForGemini(item) : item
);
} else {
cleaned[key] = this.cleanSchemaForGemini(value);
}
} else {
cleaned[key] = value;
}
}
return cleaned;
}
/**
* Check if a model supports thinking mode
*/
supportsThinking(modelName) {
return modelName.toLowerCase().includes('2.5');
}
/**
* Check if a model supports vision/image input
* All current Gemini models support vision
*/
supportsVision(modelName) {
// All Gemini models (1.5+, 2.0+, 2.5+) support vision
// Could add more specific logic here if needed in the future
return true;
}
/**
* Check if thinking mode is enabled in settings
*/
isThinkingEnabled() {
frontend
index.html:
try {
const { getCurrentSettings } = require('../services/settingsService');
const settings = getCurrentSettings();
return settings.enableThinkingGoogle !== false;
} catch (error) {
return true; // default to enabled for Google
}
}
/**
* Get thinking budget from settings
*/
getThinkingBudget() {
try {
const { getCurrentSettings } = require('../services/settingsService');
const settings = getCurrentSettings();
const rawBudget = settings.thinkingBudgetGoogle;
// Handle auto mode
if (rawBudget === -1 || rawBudget === '-1') {
return -1;
}
const budget = parseInt(rawBudget) || 8192;
return Math.max(0, Math.min(24576, budget));
} catch (error) {
return 8192;
}
}
}
module.exports = GoogleAdapter;
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.15, maximum-scale=5.0, userscalable=yes">
<title>SimpleChatJS</title>
<link rel="stylesheet" href="src/css/style.css">
<link rel="stylesheet" href="src/css/syntax.css">
<link rel="stylesheet" href="src/css/context-menu.css">
</head>
<body>
<div class="aim-container">
<!-- Chat List Sidebar -->
<div class="chat-sidebar">
<div class="sidebar-header">
<div class="user-info">
<div class="user-name">SimpleChatJS User</div>
<div class="user-status">Online</div>
</div>
</div>
<div class="chat-controls">
<button id="newChatBtn" class="btn">New Chat</button>
<button id="settingsBtn" class="btn">Settings</button>
</div>
<div class="chat-list-header">
<span>Chat History</span>
<div class="conductor-toggle">
<label>
<input type="checkbox" id="conductorMode"> Conductor
</label>
</div>
</div>
<div id="chatList" class="chat-list">
<!-- Chat items will be populated here -->
</div>
</div>
<!-- Main Chat Area -->
<div class="chat-main">
<div class="chat-header">
<div class="chat-title-section">
<div class="chat-title" id="chatTitle">Select or create a new chat</div>
<div class="chat-info" id="chatInfo"></div>
</div>
<div class="model-selector-section">
<label for="mainModelSelect" class="model-label">Model:</label>
<select id="mainModelSelect" class="model-dropdown">
<option value="">Loading...</option>
</select>
</div>
</div>
<div id="messagesContainer" class="messages-container">
<div id="messages" class="messages"></div>
</div>
<div id="inputContainer" class="input-container">
<div class="input-row">
<textarea id="messageInput" placeholder="Type your message here..." rows="2"></textarea>
<button id="sendBtn" class="btn">Send</button>
</div>
<!-- File upload and main actions area -->
<div id="imageArea" class="image-area">
<div class="main-action-bar">
<input type="file" id="fileInput" accept="*" multiple style="display: none;">
<button id="addFileBtn" class="btn" title="Add files & images">
Add Files
</button>
<button id="toolsBtn" class="btn" title="Manage tools">
Tool Settings
</button>
</div>
<div id="imagePreviews" class="image-previews"></div>
<div id="documentPreviews" class="document-previews"></div>
</div>
</div>
</div>
</div>
<!-- Settings Modal -->
<div id="settingsModal" class="aim-modal hidden">
<div class="aim-modal-content">
<div class="aim-modal-header">
<span class="aim-modal-title">Settings</span>
<span class="close">&times;</span>
</div>
<!-- Tab Navigation -->
<div class="tab-navigation">
<button class="btn btn-tab active" data-tab="general">General</button>
<button class="btn btn-tab" data-tab="tokens">Tokens</button>
<button class="btn btn-tab" data-tab="mcp">MCP</button>
<button class="btn btn-tab" data-tab="debug">Debug</button>
<button class="btn btn-tab" data-tab="logging">Logging</button>
</div>
<!-- General Tab -->
<div id="generalTab" class="tab-content active">
<!-- Profile Management Section -->
<div class="settings-section">
<h3>Profiles</h3>
<div class="profile-row">
<label for="profileSelect">Active Profile:</label>
<select id="profileSelect" class="profile-dropdown">
<option value="Default">Default</option>
</select>
<input type="text" id="newProfileName" placeholder="New profile name"
class="profile-name-input">
<button type="button" id="saveAsProfileBtn" class="btn">Save As New
Profile</button>
<button type="button" id="deleteProfileBtn" class="btn btn-danger">Delete
Profile</button>
</div>
</div>
<div class="settings-section">
<div class="api-config-header">
<h3>API Configuration</h3>
<button id="testConnectionBtn" class="test-connection-btn">Test
Connection</button>
</div>
<label for="apiKey">API Key (optional for local APIs):</label>
<input type="password" id="apiKey" placeholder="Leave empty for local APIs like
Ollama">
<label for="apiUrl">API URL (required):</label>
<input type="text" id="apiUrl" placeholder="http://localhost:11434/v1 (Ollama) or
https://api.openai.com/v1">
<label for="modelName">Model:</label>
<div class="model-selector-container">
<select id="modelSelect" class="model-dropdown">
<option value="">-- Select a model --</option>
</select>
<input type="text" id="modelName" placeholder="Or enter custom model name"
class="model-input">
<button type="button" id="refreshModelsBtn" class="refresh-models-btn"
title="Refresh model list"></button>
</div>
</div>
</div>
<!-- MCP Tab --> <!-- Tokens Tab -->
<div id="tokensTab" class="tab-content">
<!-- System Prompts Section -->
<div class="settings-section system-prompts-section">
<h3>System Prompts</h3>
<div class="checkbox-group">
<input type="checkbox" id="enableSystemPrompt" checked />
<label for="enableSystemPrompt">Enable System Prompt</label>
</div>
<p class="setting-description">Configure system instructions that guide AI behavior
across all conversations. Applied automatically to the first message in each conversation.</p>
<div class="system-prompt-group" id="systemPromptGroup">
<label for="systemPrompt">System Prompt:</label>
<textarea id="systemPrompt" rows="4" placeholder="Enter system instructions...">
</textarea>
<p class="setting-description">This prompt will be automatically added to the
beginning of new conversations with all AI providers.</p>
</div>
</div>
<!-- Anthropic Thinking Section -->
<div class="settings-section thinking-section" data-provider="anthropic">
<h3>Anthropic (Claude) Thinking</h3>
<div class="checkbox-group">
<input type="checkbox" id="enableThinkingAnthropic" />
<label for="enableThinkingAnthropic">Enable Thinking Mode</label>
</div>
<p class="setting-description">Shows Claude's step-by-step reasoning process. Works
with Claude 3.7 Sonnet and Claude 4 models. Thinking is OFF by default.</p>
<div class="thinking-budget-group" id="thinkingBudgetGroupAnthropic" style="display:
none;">
<label for="thinkingBudgetAnthropic">Thinking Budget (tokens):</label>
<div class="budget-input-container">
<input type="range" id="thinkingBudgetAnthropic" min="1024" max="32000"
step="1024" value="8192">
<span id="thinkingBudgetValueAnthropic">8192</span>
</div>
<div class="budget-presets">
<button type="button" class="budget-preset" datatarget="thinkingBudgetAnthropic" data-value="1024">Light (1K)</button>
<button type="button" class="budget-preset" datatarget="thinkingBudgetAnthropic" data-value="4096">Medium (4K)</button>
<button type="button" class="budget-preset" datatarget="thinkingBudgetAnthropic" data-value="8192">High (8K)</button>
<button type="button" class="budget-preset" datatarget="thinkingBudgetAnthropic" data-value="16384">Heavy (16K)</button>
<button type="button" class="budget-preset" datatarget="thinkingBudgetAnthropic" data-value="32000">Max (32K)</button>
</div>
<p class="setting-description">Higher budgets allow more thorough reasoning but
cost more tokens. Range: 1024-32000</p>
</div>
</div>
<!-- Google Thinking Section -->
<div class="settings-section thinking-section" data-provider="google">
<h3>Google (Gemini) Thinking</h3>
<div class="checkbox-group">
<input type="checkbox" id="enableThinkingGoogle" />
<label for="enableThinkingGoogle">Enable Thinking Mode</label>
</div>
<p class="setting-description">Controls Gemini's internal reasoning process. Works
with Gemini 2.5 Pro, Flash, and Flash-Lite models. Thinking is ON by default for 2.5 models.</p>
<div class="thinking-budget-group" id="thinkingBudgetGroupGoogle" style="display:
none;">
<label for="thinkingBudgetGoogle">Thinking Budget (tokens):</label>
<div class="budget-input-container">
<input type="range" id="thinkingBudgetGoogle" min="-1" max="24576"
step="512" value="8192">
<span id="thinkingBudgetValueGoogle">8192</span>
</div>
<div class="budget-presets">
<button type="button" class="budget-preset" datatarget="thinkingBudgetGoogle" data-value="0">Off (0)</button>
<button type="button" class="budget-preset" datatarget="thinkingBudgetGoogle" data-value="-1">Auto (-1)</button>
<button type="button" class="budget-preset" datatarget="thinkingBudgetGoogle" data-value="4096">Light (4K)</button>
<button type="button" class="budget-preset" datatarget="thinkingBudgetGoogle" data-value="8192">Medium (8K)</button>
<button type="button" class="budget-preset" datatarget="thinkingBudgetGoogle" data-value="16384">Heavy (16K)</button>
<button type="button" class="budget-preset" datatarget="thinkingBudgetGoogle" data-value="24576">Max (24K)</button>
</div>
<p class="setting-description">Range: 0-24576. Use 0 to disable, -1 for autobudget, or set a specific limit.</p>
</div>
</div>
</div>
<div id="mcpTab" class="tab-content">
<div class="settings-section">
<div class="mcp-controls">
<button id="refreshMcpBtn" class="btn">Refresh MCP Servers</button>
<button id="mcpConfigBtn" class="btn">MCP Config</button>
</div>
<div id="mcpServers">
<p>Loading MCP servers...</p>
</div>
</div>
</div>
<!-- Debug Tab -->
<div id="debugTab" class="tab-content">
<div class="settings-section">
<h3>Debug Options</h3>
<div class="checkbox-group">
<input type="checkbox" id="debugPanels" />
<label for="debugPanels">Show debug panels (+ button on messages)</label>
</div>
<p class="setting-description">Enable debug information panels that show API
requests, tool filtering, and response metadata for each message.</p>
<div class="checkbox-group">
<input type="checkbox" id="showPhaseMarkers" />
<label for="showPhaseMarkers">Show phase markers (conductor mode)</label>
</div>
<p class="setting-description">Display visual phase markers during conductor mode
conversations showing current phase progress.</p>
</div>
</div>
<!-- Logging Tab -->
<div id="loggingTab" class="tab-content">
<div class="settings-section">
<h3>Logging</h3>
<label for="logLevel">Log Level:</label>
<select id="logLevel">
<option value="DEBUG">DEBUG (All logs)</option>
<option value="INFO" selected>INFO (Normal operation)</option>
<option value="WARN">WARN (Warnings and errors)</option>
<option value="ERROR">ERROR (Errors only)</option>
</select>
</div>
</div>
<button id="saveSettings" class="btn">Save Settings</button>
</div>
</div>
<!-- MCP Config Modal -->
<div id="mcpConfigModal" class="aim-modal hidden">
<div class="aim-modal-content" style="max-width: 800px;">
<div class="aim-modal-header">
<span class="aim-modal-title">MCP Configuration</span>
<span class="close-mcp">&times;</span>
</div>
<p>Configure MCP servers using Claude Desktop JSON format:</p>
<div class="settings-section">
<label for="mcpConfigText">MCP Config JSON:</label>
<textarea id="mcpConfigText" rows="20" placeholder='{
"mcpServers": {
"filesystem": {
"command": "npx",
"args": ["-y", "@modelcontextprotocol/server-filesystem", "/path/to/allowed/files"]
},
"brave-search": {
"command": "npx",
"args": ["-y", "@modelcontextprotocol/server-brave-search"],
"env": {
"BRAVE_API_KEY": "your-api-key"
}
}
}
}'></textarea>
</div>
<div class="button-group">
<button id="saveMcpConfig" class="btn">Save MCP Config</button>
<button id="testMcpConfig" class="btn">Check JSON Format</button>
</div>
</div>
</div>
</div>
chatRenderer.js:
<!-- 1998-style script tags -->
<!-- Core app utilities -->
<script src="src/js/app/logger.js"></script>
<script src="src/js/app/utils.js"></script>
<script src="src/js/app/imageProcessing.js"></script>
<!-- Document processing (server-side via API) -->
<script src="src/js/app/documentProcessing.js"></script>
<script src="src/js/app/api.js"></script>
<!-- Rendering system -->
<script src="src/js/render/streamingDropdowns.js"></script>
<script src="src/js/render/streamingMessageProcessor.js"></script>
<script src="src/js/render/chatRenderer.js"></script>
<script src="src/js/render/liveRenderer.js"></script>
<!-- Tools -->
<script src="src/js/tools/mcp.js"></script>
<script src="src/js/tools/toolHandler.js"></script>
<!-- UI components -->
<script src="src/js/ui/debugPanel.js"></script>
<script src="src/js/ui/settings.js"></script>
<script src="src/js/ui/ui.js"></script>
<script src="src/js/ui/contextMenu.js"></script>
<!-- Chat functionality -->
<script src="src/js/chat/conductorDebugData.js"></script>
<script src="src/js/chat/conductor.js"></script>
<script src="src/js/chat/simpleChatMode.js"></script>
<script src="src/js/chat/chatManager.js"></script>
<!-- Main application -->
<script src="src/js/utils/simpleSyntax.js"></script>
<script src="src/js/app/main.js"></script>
</body>
</html>
// ChatRenderer.js
class ChatRenderer {
constructor(containerElement) {
this.container = containerElement;
}
// Main render method - handles only blocks - no more content parsing
renderTurn(turnData, shouldScroll = true) {
try {
const {
id,
role,
blocks,
content,
debug_data,
dropdownStates = {},
original_content,
turn_number,
edit_count,
edited_at
} = turnData;
// Validate required data
if (!role || turn_number === undefined) {
console.error('[RENDER-ERROR] Missing required turn data:', { role, turn_number, turnData
});
return null;
}
// Check if this turn already exists in DOM
const existingTurns = document.querySelectorAll(`[data-turn-number="${turn_number}"]`);
if (existingTurns.length > 0 && role === "assistant") {
console.warn(
`[DUPLICATE-GUARD] Turn ${turn_number} already exists in DOM! Found ${existingTurns.length}
existing turns - SKIPPING RENDER`
);
return existingTurns[0]; // Return existing turn instead of creating duplicate
}
// Handle blocks: Required for assistant messages, optional for user messages
let finalBlocks;
if (!blocks) {
if (role === "assistant") {
// Auto-generate blocks for assistant messages when missing
console.warn("[AUTO-BLOCKS] Creating blocks for assistant message from content");
finalBlocks = this.createBlocksFromContent(content);
} else {
// User messages can render without blocks
finalBlocks = [{ type: "chat", content: content || "", metadata: {} }];
}
} else {
finalBlocks = blocks;
}
const turnDiv = document.createElement("div");
const turnId = `turn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
// Use the new turn-based class names
if (role === "user") {
turnDiv.className = "turn user-turn";
} else if (role === "assistant") {
turnDiv.className = "turn assistant-turn";
} else {
turnDiv.className = `turn ${role}-turn`; // Fallback for other roles
}
turnDiv.dataset.turnId = turnId;
if (id) {
turnDiv.dataset.messageId = id;
}
if (turn_number) {
turnDiv.dataset.turnNumber = turn_number;
}
// Create content container
const contentDiv = document.createElement("div");
contentDiv.className = "turn-content";
// Always render blocks - no conditionals needed
let thinkingIndex = 0;
let toolIndex = 0;
finalBlocks.forEach((blockData) => {
let stateKey;
let isOpen = false;
if (blockData.type === "thinking") {
stateKey = "thinking_" + thinkingIndex;
thinkingIndex++;
} else if (blockData.type === "tool") {
stateKey = "tool_" + toolIndex;
toolIndex++;
}
if (stateKey) {
isOpen = dropdownStates[stateKey] || false;
}
const blockElement = this.renderBlock(blockData, isOpen);
contentDiv.appendChild(blockElement);
});
turnDiv.appendChild(contentDiv);
// Add message actions bar
this.addMessageActions(turnDiv, role, turnId, turn_number, id);
// Add debug toggle and panel if debug data provided
if (debug_data) {
this.addDebugPanel(turnDiv, turnId, debug_data, turn_number);
}
this.container.appendChild(turnDiv);
// Handle scrolling
if (shouldScroll) {
smartScrollToBottom(scrollContainer);
}
// Update chat preview and handle title generation
this.handleTurnMeta(
role,
finalBlocks
.filter((b) => b.type === "chat")
.map((b) => b.content)
.join(" ")
);
return turnDiv;
} catch (error) {
console.error('[RENDER-ERROR] Error rendering turn:', error, turnData);
// Create a simple error message instead of crashing
const errorDiv = document.createElement('div');
errorDiv.className = 'turn assistant-turn error';
errorDiv.innerHTML = `
<div class="turn-content">
<div class="error-message">Error rendering message: ${error.message}</div>
</div>
`;
return errorDiv;
}
}
// Create message element without appending to container (for seamless replacement)
createTurnElement(turnData, shouldScroll = true) {
const { id, role, blocks, content, debug_data, dropdownStates = {}, turn_number } = turnData;
// If blocks aren't provided, we have a broken pipeline
let finalBlocks;
if (!blocks) {
console.error("[BROKEN-RENDER] No blocks provided for element creation:", turnData);
throw new Error("Blocks are required for element creation - 3rd rendering path has been
removed");
} else {
finalBlocks = blocks;
}
const turnDiv = document.createElement("div");
const turnId = `turn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
// Use the new turn-based class names
if (role === "user") {
turnDiv.className = "turn user-turn";
} else if (role === "assistant") {
turnDiv.className = "turn assistant-turn";
} else {
turnDiv.className = `turn ${role}-turn`; // Fallback for other roles
}
turnDiv.dataset.turnId = turnId;
if (turn_number) {
turnDiv.dataset.turnNumber = turn_number;
}
// Create content container
const contentDiv = document.createElement("div");
contentDiv.className = "turn-content";
// Always render blocks - no conditionals needed
let thinkingIndex = 0;
let toolIndex = 0;
finalBlocks.forEach((blockData) => {
let stateKey;
let isOpen = false;
if (blockData.type === "thinking") {
stateKey = "thinking_" + thinkingIndex;
thinkingIndex++;
} else if (blockData.type === "tool") {
stateKey = "tool_" + toolIndex;
toolIndex++;
}
if (stateKey) {
isOpen = dropdownStates[stateKey] || false;
}
const blockElement = this.renderBlock(blockData, isOpen);
contentDiv.appendChild(blockElement);
});
turnDiv.appendChild(contentDiv);
// Add message actions bar
this.addMessageActions(turnDiv, role, turnId, turn_number, id);
// Add debug toggle and panel if debug data provided
if (debug_data) {
this.addDebugPanel(turnDiv, turnId, debug_data, turn_number);
}
// Handle metadata but don't scroll yet
this.handleTurnMeta(
role,
finalBlocks
.filter((b) => b.type === "chat")
.map((b) => b.content)
.join(" ")
);
return turnDiv;
}
// Render individual block based on type
renderBlock(blockData, isOpen = false) {
const { type, content, metadata = {} } = blockData;
switch (type) {
case "thinking":
return this.renderThinkingBlock(content, metadata, isOpen);
case "tool":
return this.renderToolBlock(content, metadata, isOpen);
case "codeblock":
return this.renderCodeBlock(content, metadata);
case "phase_marker":
return this.renderPhaseMarkerBlock(content, metadata);
case "error":
return this.renderErrorBlock(content, metadata);
case "chat":
default:
return this.renderChatBlock(content);
}
}
// Render thinking block as dropdown
renderThinkingBlock(content, metadata, isOpen = false) {
const dropdownId = `thinking-${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
// Use title from metadata if available (Gemini), otherwise use default
const title = metadata.title || "Thinking Process";
const dropdown = new StreamingDropdown(dropdownId, title, "thinking", !isOpen);
dropdown.setContent(content);
return dropdown.element;
}
// Render tool block as dropdown
renderToolBlock(content, metadata, isOpen = false) {
const dropdownId = `tool-${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
// Extract tool name from metadata or content
let toolName = metadata?.toolName;
if (!toolName) {
const toolMatch = content.match(/^\[(\w+)\]:/m);
if (toolMatch) {
toolName = toolMatch[1];
}
}
// Create title with just the tool name (no "Tool:" prefix)
const title = toolName || "unknown_tool";
// Format the content with Arguments and Result sections
const formattedContent = formatToolContent(content, toolName, metadata?.toolArgs);
const dropdown = new StreamingDropdown(dropdownId, title, "tool", !isOpen);
dropdown.setContent(formattedContent);
return dropdown.element;
}
// Render live streaming code block
renderCodeBlock(content, metadata) {
const div = document.createElement("div");
div.className = "live-code-block";
// Add language label if present
if (metadata.language) {
const langLabel = document.createElement("div");
langLabel.className = "code-lang";
langLabel.textContent = metadata.language;
div.appendChild(langLabel);
}
// Create the code element
const pre = document.createElement("pre");
const code = document.createElement("code");
// Add language class and streaming indicator
let codeClass = "";
if (metadata.language) {
codeClass = `language-${metadata.language}`;
}
if (metadata.isStreaming) {
code.className = `streaming-code ${codeClass}`.trim();
// For streaming, escape HTML and add cursor
code.innerHTML = escapeHtml(content) + '<span class="code-cursor">|</span>';
} else {
code.className = codeClass;
// For final content, use SimpleSyntax highlighting
code.innerHTML = window.SimpleSyntax ? SimpleSyntax.highlight(content, metadata.language) :
escapeHtml(content);
}
pre.appendChild(code);
div.appendChild(pre);
// Add copy button
const copyBtn = document.createElement("button");
copyBtn.className = "code-copy-btn";
copyBtn.textContent = "Copy";
copyBtn.addEventListener("click", () => {
this.copyCodeToClipboard(content);
});
div.appendChild(copyBtn);
return div;
}
// Render error block as dropdown with debug information
renderErrorBlock(content, metadata, isOpen = false) {
const dropdownId = `error-${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
const errorType = metadata?.error_type || 'unknown_error';
const title = `Error: ${errorType.replace('_', ' ').toUpperCase()}`;
// Create error dropdown with red styling
const dropdown = new StreamingDropdown(dropdownId, title, "error", !isOpen);
// Format error content with debug information
let errorContent = `**Error Message:**\n${content}\n\n`;
if (metadata?.debug_data) {
errorContent += `**Debug Information:**\n\`\`\`json\n${JSON.stringify(metadata.debug_data, null,
2)}\n\`\`\``;
}
dropdown.setContent(errorContent);
// Add error-specific styling
dropdown.element.classList.add('error-dropdown');
dropdown.element.style.borderLeft = '4px solid #ff4444';
// Style the dropdown toggle (header) - use correct selector and add null check
const dropdownToggle = dropdown.element.querySelector('.dropdown-toggle');
if (dropdownToggle) {
dropdownToggle.style.backgroundColor = '#4a1a1a'; // Dark red background
dropdownToggle.style.color = '#ff9999'; // Light red text
dropdownToggle.style.borderLeft = '3px solid #cc0000';
}
return dropdown.element;
}
// Copy code content to clipboard, stripping markdown backticks
copyCodeToClipboard(content) {
// Remove leading/trailing backticks and language identifier
let cleanContent = content;
// Remove opening backticks and language (e.g., "```python\n")
cleanContent = cleanContent.replace(/^```[a-zA-Z]*\n?/, '');
// Remove closing backticks
cleanContent = cleanContent.replace(/\n?```$/, '');
// Copy to clipboard
navigator.clipboard.writeText(cleanContent).then(() => {
// Provide visual feedback
const copyBtns = document.querySelectorAll('.code-copy-btn');
copyBtns.forEach(btn => {
if (btn.textContent === 'Copy') {
const originalText = btn.textContent;
btn.textContent = 'Copied!';
setTimeout(() => {
btn.textContent = originalText;
}, 1000);
}
});
}).catch(err => {
console.error('Failed to copy code:', err);
});
}
// Render regular chat content
showFileContentModal(metadata) {
// Create modal
const modal = document.createElement("div");
modal.className = "file-content-modal";
modal.innerHTML = `
<div class="modal-overlay">
<div class="modal-content">
<div class="modal-header">
<h3>${metadata.fileName}</h3>
<button class="modal-close"></button>
</div>
<div class="modal-body">
<pre class="file-content">${escapeHtml(metadata.extractedText || "No content
available")}</pre>
</div>
</div>
</div>
`;
// Add to body
document.body.appendChild(modal);
// Close handlers
const closeBtn = modal.querySelector(".modal-close");
const overlay = modal.querySelector(".modal-overlay");
const closeModal = () => {
document.body.removeChild(modal);
};
closeBtn.addEventListener("click", closeModal);
overlay.addEventListener("click", (e) => {
if (e.target === overlay) closeModal();
});
// ESC key to close
const escHandler = (e) => {
if (e.key === "Escape") {
closeModal();
document.removeEventListener("keydown", escHandler);
}
};
document.addEventListener("keydown", escHandler);
}
renderChatBlock(content) {
const div = document.createElement("div");
div.className = "chat-block";
// Handle cases where content might be JSON stringified
let processedContent = content;
if (typeof content === 'string' && content.startsWith('[')) {
try {
processedContent = JSON.parse(content);
} catch (e) {
// If parsing fails, treat as regular text
processedContent = content;
}
}
// Handle multimodal content (array) or simple text content (string)
if (Array.isArray(processedContent)) {
// Multimodal content - render each part
processedContent.forEach(part => {
switch (part.type) {
case 'text':
if (part.text !== undefined && part.text !== null && part.text !== '') {
const textDiv = document.createElement('div');
textDiv.className = 'content-part text-part';
textDiv.innerHTML = formatMessage(escapeHtml(part.text));
div.appendChild(textDiv);
}
break;
case 'image':
const imageDiv = document.createElement('div');
imageDiv.className = 'content-part image-part';
const img = document.createElement('img');
img.src = `data:${part.mimeType};base64,${part.imageData}`;
img.className = 'message-image';
img.loading = 'lazy';
img.onclick = () => this.openImageModal(img.src);
imageDiv.appendChild(img);
div.appendChild(imageDiv);
break;
case 'files':
if (part.files && Array.isArray(part.files) && part.files.length > 0) {
const filesDiv = document.createElement('div');
filesDiv.className = 'content-part files-part';
part.files.forEach(file => {
const filePreview = document.createElement('div');
filePreview.className = 'file-attachment';
const icon = document.createElement('span');
icon.className = 'file-icon';
icon.textContent = getFileIcon(file.fileName);
const info = document.createElement('div');
info.className = 'file-info';
const name = document.createElement('div');
name.className = 'file-name';
name.textContent = file.fileName;
name.title = file.fileName;
const size = document.createElement('div');
size.className = 'file-size';
size.textContent = `${(file.size / 1024).toFixed(1)}KB`;
info.appendChild(name);
info.appendChild(size);
filePreview.appendChild(icon);
filePreview.appendChild(info);
// Add click handler to show file content
filePreview.style.cursor = 'pointer';
filePreview.addEventListener('click', () => {
this.showFileContentModal({
fileName: file.fileName,
extractedText: file.extractedText,
size: file.size,
type: file.type
});
});
filesDiv.appendChild(filePreview);
});
div.appendChild(filesDiv);
}
break;
default:
console.warn('Unknown content part type:', part.type);
break;
}
});
} else {
// Simple text content (backward compatible)
div.innerHTML = formatMessage(escapeHtml(String(processedContent || '')));
}
return div;
}
// Open image in modal for full view
openImageModal(imageSrc) {
// Create modal if it doesn't exist
let modal = document.getElementById('imageModal');
if (!modal) {
modal = document.createElement('div');
modal.id = 'imageModal';
modal.className = 'image-modal hidden';
const img = document.createElement('img');
img.id = 'modalImage';
modal.appendChild(img);
// Close modal on click
modal.addEventListener('click', () => {
modal.classList.add('hidden');
});
// Close modal on Escape key
document.addEventListener('keydown', (e) => {
if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
modal.classList.add('hidden');
}
});
document.body.appendChild(modal);
}
// Set image and show modal
const modalImg = document.getElementById('modalImage');
modalImg.src = imageSrc;
modal.classList.remove('hidden');
}
// Simple phase marker rendering - no more complexity!
renderPhaseMarkerBlock(content, metadata) {
const settings = loadSettings();
const div = document.createElement("div");
div.className = "conductor-phase-marker";
div.innerHTML = `
<div class="phase-marker-content">
<span class="phase-text">${escapeHtml(content)}</span>
</div>
`;
// Apply visibility setting
if (!settings.showPhaseMarkers) {
div.style.display = "none";
}
return div;
}
// Add debug panel to message
addDebugPanel(turnDiv, messageId, debugData, turnNumber = null) {
const settings = loadSettings();
turnDiv.classList.add("has-debug");
const debugToggle = document.createElement("button");
debugToggle.className = "debug-toggle";
debugToggle.dataset.messageId = messageId;
debugToggle.innerHTML = "+";
debugToggle.title = "Show debug info";
if (!settings.debugPanels) {
debugToggle.style.display = "none";
}
// Add click handler to toggle debug panel
debugToggle.addEventListener("click", () => {
const debugPanel = turnDiv.querySelector(".debug-panel-container");
if (debugPanel) {
const isHidden = debugPanel.style.display === "none";
debugPanel.style.display = isHidden ? "block" : "none";
debugToggle.innerHTML = isHidden ? "" : "+";
debugToggle.classList.toggle("active", isHidden);
}
});
turnDiv.appendChild(debugToggle);
// Add turn ID and message ID to debug data
if (!debugData) {
debugData = {};
}
// Get the turn element that contains this message
const turnElement = turnDiv.closest(".turn");
if (turnElement) {
debugData.turnId = turnElement.dataset.turnId || "unknown";
}
// Add message ID
debugData.messageId = messageId || "unknown";
// Add turn number if provided
if (turnNumber !== null && turnNumber !== undefined) {
debugData.currentTurnNumber = turnNumber;
}
const debugPanel = createDebugPanel(turnDiv, messageId, debugData, turnNumber);
turnDiv.appendChild(debugPanel);
}
// Add message actions bar to turn
addMessageActions(turnDiv, role, turnId, turnNumber = null, messageId = null) {
const actionsContainer = document.createElement("div");
actionsContainer.className = "message-actions";
actionsContainer.dataset.turnId = turnId;
actionsContainer.dataset.role = role;
actionsContainer.dataset.turnNumber = turnNumber;
if (messageId) {
actionsContainer.dataset.messageId = messageId;
}
// Action buttons container
const actionButtons = document.createElement("div");
actionButtons.className = "action-buttons";
// Edit button
const editBtn = document.createElement("button");
editBtn.className = "action-btn edit-btn";
editBtn.title = "Edit message";
editBtn.textContent = "Edit";
editBtn.addEventListener("click", () => this.handleEditMessage(turnId, role, turnNumber,
messageId));
// Edit and retry button (for user messages)
const editRetryBtn = document.createElement("button");
editRetryBtn.className = "action-btn edit-retry-btn";
editRetryBtn.title = "Edit your message and regenerate conversation from this point";
editRetryBtn.textContent = "Edit & Retry";
editRetryBtn.addEventListener("click", () => this.handleEditAndRetry(turnId, role, turnNumber,
messageId));
// Retry button (for assistant messages)
const retryBtn = document.createElement("button");
retryBtn.className = "action-btn retry-btn";
retryBtn.title = "Generate a different response to the same prompt";
retryBtn.textContent = "Retry";
retryBtn.addEventListener("click", () => this.handleRetryMessage(turnId, role, turnNumber,
messageId));
// Add buttons to container
actionButtons.appendChild(editBtn);
// Only show "Edit & Retry" for user messages (lets them rephrase and regenerate)
if (role === "user") {
actionButtons.appendChild(editRetryBtn);
}
// Only show "Retry" for assistant messages (regenerate response)
if (role === "assistant") {
actionButtons.appendChild(retryBtn);
}
// Assemble the actions container - add action buttons first (left side)
actionsContainer.appendChild(actionButtons);
// Add branch navigation to both user and assistant turns (both can be branched)
if ((role === "user" || role === "assistant") && turnNumber) {
// Branch navigation container
const branchNav = document.createElement("div");
branchNav.className = "branch-nav";
branchNav.style.display = "none"; // Will be shown when this turn has branches
// Previous branch button
const prevBtn = document.createElement("button");
prevBtn.className = "nav-btn branch-prev";
prevBtn.innerHTML = "<";
prevBtn.title = "Previous branch";
prevBtn.addEventListener("click", () => this.navigateBranch("prev", branchNav));
// Branch indicator
const branchIndicator = document.createElement("span");
branchIndicator.className = "branch-indicator";
branchIndicator.textContent = "1/1";
// Next branch button
const nextBtn = document.createElement("button");
nextBtn.className = "nav-btn branch-next";
nextBtn.innerHTML = ">";
nextBtn.title = "Next branch";
nextBtn.addEventListener("click", () => this.navigateBranch("next", branchNav));
branchNav.appendChild(prevBtn);
branchNav.appendChild(branchIndicator);
branchNav.appendChild(nextBtn);
// Check if this turn should show branch navigation
this.updateBranchNavigation(branchNav, turnNumber).catch((error) => {
console.error("[BRANCH-NAV] Error loading branch info:", error);
// Hide navigation on error
branchNav.style.display = "none";
});
// Add branch nav to actions container after action buttons
actionsContainer.appendChild(branchNav);
}
// Insert before debug toggle if it exists, otherwise just append
const debugToggle = turnDiv.querySelector(".debug-toggle");
if (debugToggle) {
turnDiv.insertBefore(actionsContainer, debugToggle);
} else {
turnDiv.appendChild(actionsContainer);
}
}
// Handle turn-level editing - show all messages in the turn
async handleEditMessage(turnId, role, turnNumber, messageId) {
if (!turnNumber) {
showError("Cannot edit: Turn number not available");
return;
}
const turnDiv = document.querySelector(`[data-turn-id="${turnId}"]`);
if (!turnDiv) {
showError("Cannot edit: Turn element not found");
return;
}
// Check if already in edit mode
if (turnDiv.classList.contains("editing")) {
return;
}
try {
// Get all messages for this turn
const response = await getTurnMessages(currentChatId, turnNumber);
if (!response || !response.messages) {
showError("Cannot edit: Invalid response from server");
console.error("[EDIT] Invalid response:", response);
return;
}
const turnMessages = response.messages;
if (!Array.isArray(turnMessages) || turnMessages.length === 0) {
showError("Cannot edit: No messages found for this turn");
return;
}
// Enter message-based edit mode
this.enterMessageEditMode(turnDiv, turnMessages, turnNumber);
} catch (error) {
console.error("[EDIT] Error getting turn messages:", error);
showError(`Error loading turn for editing: ${error.message}`);
}
}
async handleEditAndRetry(turnId, role, turnNumber, messageId) {
// Only allow edit & retry for user messages
if (role !== "user") {
return;
}
if (!turnNumber) {
return;
}
// Set a flag that this turn should retry after editing
const turnDiv = document.querySelector(`[data-turn-id="${turnId}"]`);
if (turnDiv) {
turnDiv.dataset.shouldRetryAfterEdit = "true";
turnDiv.dataset.editRetryTurnNumber = turnNumber;
}
// Call the regular edit function - it will use the proper modal
await this.handleEditMessage(turnId, role, turnNumber, messageId);
}
async handleRetryMessage(turnId, role, turnNumber, messageId) {
// Only allow retry for assistant messages
if (role !== "assistant") {
return;
}
if (!turnNumber) {
console.error("[RETRY] Cannot retry: Turn number not available");
return;
}
try {
// Show loading state
const turnDiv = document.querySelector(`[data-turn-id="${turnId}"]`);
if (turnDiv) {
const retryBtn = turnDiv.querySelector(".retry-btn");
if (retryBtn) {
retryBtn.textContent = "Retrying...";
retryBtn.disabled = true;
}
}
// 1. Create new branch with truncated history (backend handles this)
const branchInfo = await retryTurn(currentChatId, turnNumber);
// 2. Get the chat history to find the last user message (before truncation)
const history = await getChatHistory(currentChatId);
const allMessages = history.messages || [];
// Find the last user message in the truncated history
const userMessages = allMessages.filter((msg) => msg.role === "user");
if (userMessages.length === 0) {
console.error("[RETRY] No user messages found in truncated history");
return;
}
const lastUserMessage = userMessages[userMessages.length - 1];
// 3. Truncate UI to show only messages up to the last user message
// Remove all turns after the user turn we're retrying from
const allTurns = this.container.querySelectorAll(".turn");
let foundRetryPoint = false;
for (let i = allTurns.length - 1; i >= 0; i--) {
const turn = allTurns[i];
const turnTurnNumber = parseInt(turn.dataset.turnNumber);
if (turnTurnNumber >= turnNumber) {
turn.remove();
foundRetryPoint = true;
}
}
if (!foundRetryPoint) {
console.warn(`[RETRY] Could not find turn ${turnNumber} to truncate from`);
}
// 4. Generate assistant response using the same pattern as simpleChatMode
const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
await loadEnabledToolsFromBackend(); // Ensure cache is loaded
const enabledToolsFlags = loadEnabledTools(); // Get flags like {"server.tool": false}
const requestInfo = initiateMessageRequest(
lastUserMessage.content,
false,
enabledToolsFlags,
null,
null,
false,
false,
requestId
);
const response = await requestInfo.fetchPromise;
// 5. Process the streaming response like normal chat
await this.processRetryResponse(response, currentChatId, turnNumber, requestId);
// 6. Update branch navigation for all turns after retry
// Give a small delay to ensure the DOM has been updated
setTimeout(async () => {
await this.refreshBranchNavigation();
}, 100); // Shorter delay since we're not reloading everything
} catch (error) {
console.error("[RETRY] Error:", error);
} finally {
// Restore button state
const turnDiv = document.querySelector(`[data-turn-id="${turnId}"]`);
if (turnDiv) {
const retryBtn = turnDiv.querySelector(".retry-btn");
if (retryBtn) {
retryBtn.textContent = "Retry";
retryBtn.disabled = false;
}
}
}
}
// Enter edit mode for a message
enterEditMode(turnDiv, chatBlock, messageData, messageId) {
// Mark as editing
turnDiv.classList.add("editing");
// Store original content
const originalHtml = chatBlock.innerHTML;
// Create edit container
const editContainer = document.createElement("div");
editContainer.className = "edit-container";
// Create textarea with current content
const textarea = document.createElement("textarea");
textarea.className = "edit-textarea";
textarea.value = messageData.content;
textarea.rows = Math.max(3, messageData.content.split("\n").length + 1);
// Create edit controls
const editControls = document.createElement("div");
editControls.className = "edit-controls";
const saveBtn = document.createElement("button");
saveBtn.className = "btn btn-success edit-btn-save";
saveBtn.textContent = "Save";
const cancelBtn = document.createElement("button");
cancelBtn.className = "btn btn-danger edit-btn-cancel";
cancelBtn.textContent = "Cancel";
// Add event handlers
saveBtn.addEventListener("click", () => {
this.saveEdit(turnDiv, chatBlock, textarea.value, messageId, originalHtml);
});
cancelBtn.addEventListener("click", () => {
this.cancelEdit(turnDiv, chatBlock, originalHtml);
});
// Handle Escape key to cancel
textarea.addEventListener("keydown", (e) => {
if (e.key === "Escape") {
this.cancelEdit(turnDiv, chatBlock, originalHtml);
}
// Ctrl+Enter to save
if (e.key === "Enter" && e.ctrlKey) {
this.saveEdit(turnDiv, chatBlock, textarea.value, messageId, originalHtml);
}
});
// Assemble edit UI
editControls.appendChild(saveBtn);
editControls.appendChild(cancelBtn);
editContainer.appendChild(textarea);
editContainer.appendChild(editControls);
// Replace chat block content with edit UI
chatBlock.innerHTML = "";
chatBlock.appendChild(editContainer);
// Focus the textarea
textarea.focus();
textarea.select();
}
// Save the edited message
async saveEdit(turnDiv, chatBlock, newContent, messageId, originalHtml) {
if (!newContent.trim()) {
showError("Message cannot be empty");
return;
}
try {
// Show loading state
const saveBtn = turnDiv.querySelector(".edit-btn-save");
const originalSaveText = saveBtn.textContent;
saveBtn.textContent = "Saving...";
saveBtn.disabled = true;
// Call API to update message
const result = await editMessage(messageId, newContent.trim());
// Update the UI with new content
chatBlock.innerHTML = formatMessage(escapeHtml(newContent.trim()));
// Exit edit mode
turnDiv.classList.remove("editing");
// Show edit indicator if this was edited
if (result.edit_count > 1) {
this.addEditIndicator(turnDiv, result.edit_count);
}
} catch (error) {
console.error("[EDIT] Error saving message:", error);
showError(`Error saving message: ${error.message}`);
// Restore original content on error
chatBlock.innerHTML = originalHtml;
turnDiv.classList.remove("editing");
}
}
// Cancel editing and restore original content
cancelEdit(turnDiv, chatBlock, originalHtml) {
chatBlock.innerHTML = originalHtml;
turnDiv.classList.remove("editing");
}
// Add visual indicator that message was edited
addEditIndicator(turnDiv, editCount) {
// Remove existing indicator
const existing = turnDiv.querySelector(".edit-indicator");
if (existing) {
existing.remove();
}
// Add new indicator
const indicator = document.createElement("span");
indicator.className = "edit-indicator";
indicator.textContent = `(edited ${editCount}x)`;
indicator.title = "This message has been edited";
// Insert after the turn content
const turnContent = turnDiv.querySelector(".turn-content");
if (turnContent) {
turnContent.appendChild(indicator);
}
}
// Find message ID for a turn by looking it up in the database
async findMessageIdForTurn(turnNumber, role) {
try {
// Use global variables
const apiBase = window.location.origin;
const chatId = currentChatId; // Global variable from utils.js
if (!chatId) {
console.error("[EDIT] No current chat ID available");
return null;
}
// Get current chat history to find the message
const response = await fetch(`${apiBase}/api/chat/${chatId}/history`);
if (!response.ok) {
throw new Error(`HTTP ${response.status}: ${response.statusText}`);
}
const history = await response.json();
// Find message with matching turn number and role
const message = history.messages.find((msg) => msg.turn_number === turnNumber && msg.role ===
role);
return message ? message.id : null;
} catch (error) {
console.error("[EDIT] Error finding message ID:", error);
return null;
}
}
// Legacy function - removed, use enterMessageEditMode instead
enterTurnEditMode() {
throw new Error("This function has been replaced by enterMessageEditMode");
}
// ===== UTILITY METHODS =====
// Utility function to safely extract text content from multimodal or string content
getTextContent(content) {
if (typeof content === 'string') {
return content;
}
if (Array.isArray(content)) {
// Extract text from multimodal array
const textPart = content.find(part => part.type === 'text');
return textPart ? textPart.text : '[Images only]';
}
return String(content || '');
}
// Create blocks from content (for assistant messages that don't have blocks)
createBlocksFromContent(content) {
if (!content) {
return [{ type: "chat", content: "", metadata: {} }];
}
// If content is already a string, create a simple chat block
if (typeof content === 'string') {
return [{ type: "chat", content: content, metadata: {} }];
}
// If content is an array (multimodal), convert to appropriate blocks
if (Array.isArray(content)) {
const blocks = [];
content.forEach(part => {
if (part.type === 'text' && part.text) {
blocks.push({ type: "chat", content: part.text, metadata: {} });
} else if (part.type === 'image') {
// Create an image block
blocks.push({
type: "image",
content: `![Image](data:${part.mimeType};base64,${part.imageData})`,
metadata: {
mimeType: part.mimeType,
imageData: part.imageData
}
});
}
});
// If no blocks were created, add an empty chat block
if (blocks.length === 0) {
blocks.push({ type: "chat", content: "", metadata: {} });
}
return blocks;
}
// Fallback for unexpected content types
return [{ type: "chat", content: String(content), metadata: {} }];
}
// ===== EDIT SYSTEM =====
// Remove an image from the edit modal
removeImageFromEdit(messageContainer, imageIndex) {
if (!messageContainer._originalContent || !Array.isArray(messageContainer._originalContent)) {
console.warn('[IMAGE-REMOVE] Cannot remove image - content is not multimodal',
messageContainer._originalContent);
return;
}
// Remove the image from the original content array
let imageCount = 0;
messageContainer._originalContent = messageContainer._originalContent.filter(part => {
if (part.type === 'image') {
if (imageCount === imageIndex) {
imageCount++;
return false; // Remove this image
}
imageCount++;
}
return true; // Keep text parts and other images
});
// Update the hasImages flag
const remainingImages = messageContainer._originalContent.filter(part => part.type === 'image');
messageContainer._hasImages = remainingImages.length > 0;
// Update the textarea placeholder
const textarea = messageContainer.querySelector('.message-content-textarea');
if (textarea) {
textarea.placeholder = remainingImages.length > 0 ?
"Edit text content (images shown above)" :
"Enter message content";
}
// Regenerate the images display
this.updateImagesDisplay(messageContainer);
console.log(`[IMAGE-REMOVE] Removed image ${imageIndex}, ${remainingImages.length} images
remaining`);
}
// Handle file selection in edit modal
handleEditImageSelect(event, messageContainer) {
const files = Array.from(event.target.files);
this.handleEditImageFiles(files, messageContainer, 'file');
// Clear the input so the same file can be selected again
event.target.value = '';
}
// Handle image files in edit modal (similar to main handleImageFiles)
handleEditImageFiles(files, messageContainer, source = 'file') {
const imageFiles = files.filter(file => file.type.startsWith('image/'));
if (imageFiles.length === 0) {
console.warn('[EDIT-IMAGES] No valid image files selected');
return;
}
if (source === 'paste' || source === 'clipboard') {
const textarea = messageContainer.querySelector('.message-content-textarea');
if (textarea) {
const originalPlaceholder = textarea.placeholder;
textarea.placeholder = ` Pasted ${imageFiles.length} image${imageFiles.length > 1 ? 's' : ''}`;
setTimeout(() => {
textarea.placeholder = originalPlaceholder;
}, 2000);
}
}
let processedCount = 0;
imageFiles.forEach(async (file) => {
try {
// Use shared image processing logic
const processedImage = await processImageFile(file);
// Convert to edit modal format
const imageData = {
type: 'image',
imageData: processedImage.data, // Convert 'data' to 'imageData'
mimeType: processedImage.mimeType,
name: processedImage.name,
size: processedImage.size
};
if (!Array.isArray(messageContainer._originalContent)) {
const currentText = messageContainer.querySelector('.message-content-textarea').value;
messageContainer._originalContent = [
{ type: 'text', text: currentText }
];
console.warn('[EDIT-IMAGES] Had to convert _originalContent to array format');
}
messageContainer._originalContent.push(imageData);
messageContainer._hasImages = true;
const textarea = messageContainer.querySelector('.message-content-textarea');
if (textarea) {
textarea.placeholder = "Edit text content (images shown above)";
}
processedCount++;
if (processedCount === imageFiles.length) {
this.updateImagesDisplay(messageContainer);
}
console.log(`[EDIT-IMAGES] Added image: ${processedImage.name} (${(processedImage.originalSize /
1024).toFixed(1)}KB  ${(processedImage.size / 1024).toFixed(1)}KB)`);
} catch (error) {
console.error(`[EDIT-IMAGES] Error processing image ${file.name}:`, error);
}
});
}
// Setup drag & drop for edit modal message container
setupEditDragAndDrop(messageContainer) {
// Drag & drop support
messageContainer.addEventListener('dragover', (e) => {
e.preventDefault();
messageContainer.classList.add('drag-over');
});
messageContainer.addEventListener('dragleave', (e) => {
e.preventDefault();
// Only remove drag-over if we're actually leaving the container
if (!messageContainer.contains(e.relatedTarget)) {
messageContainer.classList.remove('drag-over');
}
});
messageContainer.addEventListener('drop', (e) => {
e.preventDefault();
messageContainer.classList.remove('drag-over');
const files = Array.from(e.dataTransfer.files);
if (files.length > 0) {
this.handleEditFiles(files, messageContainer, 'drop');
}
});
// Clipboard paste support
const textarea = messageContainer.querySelector('.message-content-textarea');
if (textarea) {
textarea.addEventListener('paste', (e) => {
this.handleEditClipboardPaste(e, messageContainer);
});
}
}
// Handle clipboard paste in edit modal
handleEditClipboardPaste(event, messageContainer) {
const clipboardData = event.clipboardData || window.clipboardData;
const items = clipboardData.items;
let hasFiles = false;
const pastedFiles = [];
// Check for file items in clipboard
for (let i = 0; i < items.length; i++) {
const item = items[i];
if (item.kind === 'file') {
hasFiles = true;
const file = item.getAsFile();
if (file) {
pastedFiles.push(file);
}
}
}
// If we found files, prevent default paste and handle them
if (hasFiles && pastedFiles.length > 0) {
event.preventDefault();
this.handleEditFiles(pastedFiles, messageContainer, 'paste');
console.log(`[EDIT-FILES] Pasted ${pastedFiles.length} file(s) from clipboard`);
}
}
// Handle file selection in edit modal (images + documents)
handleEditFileSelect(event, messageContainer) {
const files = Array.from(event.target.files);
this.handleEditFiles(files, messageContainer, 'file');
// Clear the input so the same file can be selected again
event.target.value = '';
}
// Handle all file types in edit modal
handleEditFiles(files, messageContainer, source = 'file') {
const imageFiles = files.filter(file => file.type.startsWith('image/'));
const documentFiles = files.filter(file => !file.type.startsWith('image/'));
// Process images (existing logic)
if (imageFiles.length > 0) {
this.handleEditImageFiles(imageFiles, messageContainer, source);
}
// Process documents (new logic)
if (documentFiles.length > 0) {
this.handleEditDocumentFiles(documentFiles, messageContainer, source);
}
}
// Handle document files in edit modal
async handleEditDocumentFiles(files, messageContainer, source = 'file') {
if (files.length === 0) {
console.warn('[EDIT-DOCUMENTS] No document files selected');
return;
}
const textarea = messageContainer.querySelector('.message-content-textarea');
if (!textarea) {
console.error('[EDIT-DOCUMENTS] No textarea found in message container');
return;
}
// Show processing feedback
const originalPlaceholder = textarea.placeholder;
textarea.placeholder = `Processing ${files.length} document${files.length > 1 ? 's' : ''}...`;
try {
// Upload documents to server for processing
const result = await processDocumentFiles(files);
// Initialize documents array if it doesn't exist
if (!messageContainer._editDocuments) {
messageContainer._editDocuments = [];
}
// Add processed documents to the container's document list (like main chat)
for (const docData of result.results) {
messageContainer._editDocuments.push(docData);
console.log(`[EDIT-DOCUMENTS] Added document: ${docData.fileName} (${(docData.size /
1024).toFixed(1)}KB)`);
}
// Handle errors
for (const error of result.errors || []) {
console.error(`[EDIT-DOCUMENTS] Error processing: ${error.fileName} - ${error.error}`);
}
// Update the documents display (like images)
this.updateEditDocumentsDisplay(messageContainer);
// Show completion feedback
if (result.failed > 0) {
textarea.placeholder = ` Processed ${result.processed}/${files.length} documents
(${result.failed} failed)`;
} else {
textarea.placeholder = ` Processed ${result.processed} document${result.processed > 1 ? 's'
: ''}`;
}
} catch (error) {
console.error('[EDIT-DOCUMENTS] Error uploading documents:', error);
textarea.placeholder = `Error: ${error.message}`;
}
// Reset placeholder after delay
setTimeout(() => {
textarea.placeholder = originalPlaceholder;
}, 3000);
}
// Update the documents display in edit modal
updateEditDocumentsDisplay(messageContainer) {
let documentsContainer = messageContainer.querySelector('.edit-documents-container');
const documents = messageContainer._editDocuments || [];
if (documents.length === 0) {
// Remove container if no documents
if (documentsContainer) {
documentsContainer.remove();
}
return;
}
// Create container if it doesn't exist
if (!documentsContainer) {
documentsContainer = document.createElement("div");
documentsContainer.className = "edit-documents-container";
const documentsHeader = document.createElement("div");
documentsHeader.className = "edit-documents-header";
documentsHeader.textContent = "Documents:";
const documentsGrid = document.createElement("div");
documentsGrid.className = "edit-documents-grid";
documentsContainer.appendChild(documentsHeader);
documentsContainer.appendChild(documentsGrid);
// Insert before textarea
const textarea = messageContainer.querySelector('.message-content-textarea');
messageContainer.insertBefore(documentsContainer, textarea);
}
// Update documents grid
const documentsGrid = documentsContainer.querySelector('.edit-documents-grid');
documentsGrid.innerHTML = '';
documents.forEach((docData, index) => {
const docPreview = document.createElement("div");
docPreview.className = "edit-document-preview";
const icon = document.createElement("span");
icon.className = "doc-icon";
icon.textContent = getFileIcon(docData.fileName);
const info = document.createElement("div");
info.className = "doc-info";
const name = document.createElement("div");
name.className = "doc-name";
name.textContent = docData.fileName;
name.title = docData.fileName;
const size = document.createElement("div");
size.className = "doc-size";
size.textContent = `${(docData.size / 1024).toFixed(1)}KB`;
info.appendChild(name);
info.appendChild(size);
const removeBtn = document.createElement("button");
removeBtn.className = "remove-btn";
removeBtn.innerHTML = '';
removeBtn.title = 'Remove document';
removeBtn.onclick = () => this.removeEditDocument(messageContainer, index);
docPreview.appendChild(icon);
docPreview.appendChild(info);
docPreview.appendChild(removeBtn);
documentsGrid.appendChild(docPreview);
});
}
// Remove a document from edit modal
removeEditDocument(messageContainer, index) {
if (!messageContainer._editDocuments) return;
messageContainer._editDocuments.splice(index, 1);
this.updateEditDocumentsDisplay(messageContainer);
console.log(`[EDIT-DOCUMENTS] Removed document at index ${index}`);
}
// Update the images display in edit modal
updateImagesDisplay(messageContainer) {
let imagesContainer = messageContainer.querySelector('.edit-images-container');
// Defensive check for _originalContent
const remainingImages = (messageContainer._originalContent &&
Array.isArray(messageContainer._originalContent)) ?
messageContainer._originalContent.filter(part => part.type === 'image') : [];
if (remainingImages.length === 0) {
// No images left - remove the entire images container if it exists
if (imagesContainer) {
imagesContainer.remove();
}
return;
}
// Create images container if it doesn't exist
if (!imagesContainer) {
imagesContainer = document.createElement("div");
imagesContainer.className = "edit-images-container";
const imagesHeader = document.createElement("div");
imagesHeader.className = "edit-images-header";
imagesContainer.appendChild(imagesHeader);
const imagesGrid = document.createElement("div");
imagesGrid.className = "edit-images-grid";
imagesContainer.appendChild(imagesGrid);
// Insert before the textarea (images show above text)
const textarea = messageContainer.querySelector('.message-content-textarea');
if (textarea) {
messageContainer.insertBefore(imagesContainer, textarea);
} else {
// Fallback: insert at the top
messageContainer.insertBefore(imagesContainer, messageContainer.firstChild);
}
}
// Update the header and regenerate the grid
const header = imagesContainer.querySelector('.edit-images-header');
if (header) {
header.innerHTML = `<strong>Images (${remainingImages.length}):</strong>`;
}
const grid = imagesContainer.querySelector('.edit-images-grid');
if (grid) {
grid.innerHTML = ''; // Clear existing previews
// Regenerate image previews with new indices
remainingImages.forEach((imageData, idx) => {
const imagePreview = document.createElement("div");
imagePreview.className = "edit-image-preview";
imagePreview.dataset.imageIndex = idx;
const img = document.createElement("img");
img.src = `data:${imageData.mimeType};base64,${imageData.imageData}`;
img.style.maxWidth = "150px";
img.style.maxHeight = "150px";
img.style.border = "1px solid #666";
img.style.borderRadius = "4px";
// Add remove button
const removeBtn = document.createElement("button");
removeBtn.className = "edit-image-remove";
removeBtn.innerHTML = '<span class="x-icon"></span>';
removeBtn.title = "Remove this image";
removeBtn.addEventListener("click", (e) => {
e.preventDefault();
e.stopPropagation();
this.removeImageFromEdit(messageContainer, idx);
});
imagePreview.appendChild(img);
imagePreview.appendChild(removeBtn);
grid.appendChild(imagePreview);
});
}
}
enterMessageEditMode(turnDiv, messages, turnNumber) {
turnDiv.classList.add("editing");
// Store original child elements
const originalElements = Array.from(turnDiv.children);
turnDiv._originalElements = originalElements;
// Create edit container
const editContainer = document.createElement("div");
editContainer.className = "message-edit-container";
// Add header
const header = document.createElement("div");
header.className = "edit-header";
header.innerHTML = `<h3>Edit Turn ${turnNumber} Messages</h3>`;
editContainer.appendChild(header);
// Create edit form for each message
const editForm = document.createElement("div");
editForm.className = "edit-form";
messages.forEach((message, index) => {
const messageContainer = document.createElement("div");
messageContainer.className = "editable-message";
messageContainer.dataset.messageId = message.id;
// Message header
const messageHeader = document.createElement("div");
messageHeader.className = "message-header";
messageHeader.innerHTML = `<strong>${message.role}</strong> (ID: ${message.id})`;
messageContainer.appendChild(messageHeader);
// Handle multimodal content properly - parse JSON strings if needed
let textContent = "";
let images = [];
let files = []; // Extract files from separated structure
let parsedContent = message.content;
// Check if we have original_content with separated files
if (message.original_content) {
parsedContent = message.original_content;
console.log(`[EDIT] Using original_content for message ${message.id}:`, parsedContent);
}
// Parse JSON string if content is a string that looks like JSON
if (typeof message.content === 'string' && message.content.startsWith('[')) {
try {
parsedContent = JSON.parse(message.content);
} catch (e) {
// If parsing fails, treat as regular text
parsedContent = message.content;
}
}
if (Array.isArray(parsedContent)) {
// Multimodal content - extract text, images, and files
const textPart = parsedContent.find(part => part.type === 'text');
textContent = textPart ? textPart.text : "";
images = parsedContent.filter(part => part.type === 'image');
// Extract files from separated structure
const filesPart = parsedContent.find(part => part.type === 'files');
if (filesPart && filesPart.files && Array.isArray(filesPart.files)) {
files = filesPart.files;
console.log(`[EDIT] Extracted ${files.length} file(s) from message ${message.id}`);
}
} else {
// Regular text content
textContent = parsedContent || "";
}
// Images will be shown via updateImagesDisplay after drag/drop setup
// Textarea for text content
const textarea = document.createElement("textarea");
textarea.className = "message-content-textarea";
textarea.value = textContent;
textarea.rows = Math.max(3, textContent.split("\n").length + 1);
// Update placeholder to reflect both images and files
const attachmentInfo = [];
if (images.length > 0) attachmentInfo.push(`${images.length} image(s)`);
if (files.length > 0) attachmentInfo.push(`${files.length} file(s)`);
textarea.placeholder = attachmentInfo.length > 0
? `Edit text content (${attachmentInfo.join(' and ')} shown above)`
: "Enter message content";
messageContainer.appendChild(textarea);
// Add image controls (file input + paperclip button + drag/drop area) at the bottom
const imageControlsContainer = document.createElement("div");
imageControlsContainer.className = "edit-image-controls";
// Hidden file input
const fileInput = document.createElement("input");
fileInput.type = "file";
fileInput.accept = "*";
fileInput.multiple = true;
fileInput.style.display = "none";
fileInput.addEventListener("change", (e) => {
this.handleEditFileSelect(e, messageContainer);
});
// Paperclip button
const addImageBtn = document.createElement("button");
addImageBtn.type = "button";
addImageBtn.className = "btn edit-add-image-btn";
addImageBtn.innerHTML = 'Add Files';
addImageBtn.title = "Add files & images";
addImageBtn.addEventListener("click", () => {
fileInput.click();
});
imageControlsContainer.appendChild(fileInput);
imageControlsContainer.appendChild(addImageBtn);
messageContainer.appendChild(imageControlsContainer);
// Store original content structure for reconstruction
// Ensure _originalContent is always an array for consistent handling
if (Array.isArray(parsedContent)) {
messageContainer._originalContent = parsedContent;
} else {
// Convert string content to array format
messageContainer._originalContent = [{ type: 'text', text: parsedContent || '' }];
}
messageContainer._hasImages = images.length > 0;
messageContainer._hasFiles = files.length > 0;
// Initialize files for edit modal
if (!messageContainer._editDocuments) {
messageContainer._editDocuments = [];
}
// Add extracted files to edit documents
messageContainer._editDocuments.push(...files);
console.log(`[EDIT-INIT] Initialized ${message.role} message:`, {
originalFormat: typeof message.content,
parsedFormat: typeof parsedContent,
finalFormat: Array.isArray(messageContainer._originalContent) ? 'array' : typeof
messageContainer._originalContent,
hasImages: messageContainer._hasImages,
hasFiles: messageContainer._hasFiles,
imageCount: images.length,
fileCount: files.length
});
// Add drag & drop support to this message container
this.setupEditDragAndDrop(messageContainer);
// Display any existing images and files
this.updateImagesDisplay(messageContainer);
this.updateEditDocumentsDisplay(messageContainer); // Display extracted files
editForm.appendChild(messageContainer);
});
editContainer.appendChild(editForm);
// Add buttons
const buttonContainer = document.createElement("div");
buttonContainer.className = "edit-buttons";
const saveBtn = document.createElement("button");
saveBtn.className = "btn btn-success edit-btn-save";
saveBtn.textContent = "Save All Messages";
saveBtn.addEventListener("click", () => {
this.saveAllMessages(turnDiv, editContainer, turnNumber);
});
const cancelBtn = document.createElement("button");
cancelBtn.className = "btn btn-danger edit-btn-cancel";
cancelBtn.textContent = "Cancel";
cancelBtn.addEventListener("click", () => {
this.cancelMessageEdit(turnDiv);
});
buttonContainer.appendChild(saveBtn);
buttonContainer.appendChild(cancelBtn);
editContainer.appendChild(buttonContainer);
// Clear and add edit interface
turnDiv.innerHTML = "";
turnDiv.appendChild(editContainer);
}
// Save all edited messages
async saveAllMessages(turnDiv, editContainer, turnNumber) {
const messageContainers = editContainer.querySelectorAll(".editable-message");
const saveBtn = editContainer.querySelector(".edit-btn-save");
try {
saveBtn.textContent = "Saving...";
saveBtn.disabled = true;
// Check if this is an "Edit & Retry" - if so, skip saving edits to preserve original branch
const isEditRetry = turnDiv.dataset.shouldRetryAfterEdit === "true";
if (!isEditRetry) {
// Save each message (normal edit without retry)
const savePromises = Array.from(messageContainers).map(async (container) => {
const messageId = container.dataset.messageId;
const textarea = container.querySelector(".message-content-textarea");
const newTextContent = textarea.value;
if (messageId && newTextContent !== undefined) {
// Reconstruct content properly - _originalContent is always an array now
let finalContent;
if (Array.isArray(container._originalContent)) {
// Reconstruct content with text, images, AND files
const reconstructedArray = [];
// Add text part
if (newTextContent) {
reconstructedArray.push({ type: 'text', text: newTextContent });
}
// Add existing images (unchanged)
const images = container._originalContent.filter(part => part.type === 'image');
reconstructedArray.push(...images);
// Add files from edit documents
if (container._editDocuments && container._editDocuments.length > 0) {
reconstructedArray.push({
type: 'files',
files: container._editDocuments
});
}
// Determine if we need multimodal format
const hasMultipleTypes = reconstructedArray.length > 1 ||
reconstructedArray.some(part => part.type !== 'text');
if (hasMultipleTypes) {
finalContent = reconstructedArray;
} else {
finalContent = newTextContent; // Text-only, send as string
}
} else {
// Fallback for old format
finalContent = newTextContent;
}
console.log(`[EDIT-SAVE] Saving message ${messageId}:`, {
textContent: newTextContent,
hasFiles: container._editDocuments?.length > 0,
fileCount: container._editDocuments?.length || 0,
finalContent: typeof finalContent === 'string' ? 'string' : 'multimodal'
});
return editMessage(messageId, finalContent);
}
});
await Promise.all(savePromises.filter(Boolean));
}
// Exit edit mode and reload
await this.exitMessageEditMode(turnDiv, turnNumber);
} catch (error) {
console.error("[EDIT] Error saving messages:", error);
showError(`Error saving messages: ${error.message}`);
saveBtn.textContent = "Save All Messages";
saveBtn.disabled = false;
}
}
// Cancel message editing
cancelMessageEdit(turnDiv) {
// Restore original elements
turnDiv.innerHTML = "";
if (turnDiv._originalElements) {
turnDiv._originalElements.forEach((element) => {
turnDiv.appendChild(element);
});
delete turnDiv._originalElements;
}
turnDiv.classList.remove("editing");
}
// Exit edit mode and reload the turn with updated content
async exitMessageEditMode(turnDiv, turnNumber) {
try {
// Check if this was an Edit & Retry
const shouldRetry = turnDiv.dataset.shouldRetryAfterEdit === "true";
const retryTurnNumber = parseInt(turnDiv.dataset.editRetryTurnNumber);
turnDiv.classList.remove("editing");
if (shouldRetry && retryTurnNumber) {
// Clear the retry flags
delete turnDiv.dataset.shouldRetryAfterEdit;
delete turnDiv.dataset.editRetryTurnNumber;
// Wait a moment to ensure edit save completes
await new Promise((resolve) => setTimeout(resolve, 100));
// Get the edited content from UI (since we skipped saving to preserve original branch)
const messageContainers = turnDiv.querySelectorAll("[data-message-id]");
let editedContent = null;
// Find the user message textarea with edited content and reconstruct properly
for (const container of messageContainers) {
const textarea = container.querySelector(".message-content-textarea");
if (textarea) {
const newTextContent = textarea.value;
// Reconstruct content with separated structure (like main chat)
if (Array.isArray(container._originalContent)) {
const reconstructedArray = [];
// Add text part
if (newTextContent) {
reconstructedArray.push({ type: 'text', text: newTextContent });
}
// Add existing images (unchanged)
const images = container._originalContent.filter(part => part.type === 'image');
reconstructedArray.push(...images);
// Add files from edit documents (separated structure)
if (container._editDocuments && container._editDocuments.length > 0) {
reconstructedArray.push({
type: 'files',
files: container._editDocuments
});
}
// Determine if we need multimodal format
const hasMultipleTypes = reconstructedArray.length > 1 ||
reconstructedArray.some(part => part.type !== 'text');
if (hasMultipleTypes) {
editedContent = reconstructedArray;
} else {
editedContent = newTextContent; // Text-only, send as string
}
} else {
// Fallback for old format
editedContent = newTextContent;
}
break;
}
}
if (!editedContent) {
console.error("[EDIT-RETRY] Could not find edited content in UI");
return;
}
// Now create branch at this user turn
const branchInfo = await retryTurn(currentChatId, retryTurnNumber);
// CRITICAL: Save the edited user message to the new branch (so it persists on reload)
// The original branch keeps the original message unchanged
// Convert multimodal arrays to JSON strings for database storage
const contentForSave = Array.isArray(editedContent) ? JSON.stringify(editedContent) :
editedContent;
await saveCompleteMessage(
currentChatId,
{ role: "user", content: contentForSave },
null,
retryTurnNumber
);
// Truncate UI - remove all turns after the edited turn (keep existing turns up to edit
point)
const allTurns = this.container.querySelectorAll(".turn");
for (let i = allTurns.length - 1; i >= 0; i--) {
const turn = allTurns[i];
const turnTurnNumber = parseInt(turn.dataset.turnNumber);
const role = turn.classList.contains("user-turn") ? "user" : "assistant";
if (turnTurnNumber >= retryTurnNumber) {
turn.remove();
}
}
// Generate new requestId for this retried request
const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
await loadEnabledToolsFromBackend(); // Ensure cache is loaded
const enabledToolsFlags = loadEnabledTools(); // Get flags like {"server.tool": false}
// Construct user debug data for the new user turn
const userDebugData = {
sequence: [
{
type: "user_input",
step: 1,
data: {
userQuery: {
message: editedContent,
chat_id: currentChatId,
conductor_mode: false, // Assuming simple chat mode for retry
timestamp: new Date().toISOString(),
message_length: Array.isArray(editedContent) ?
JSON.stringify(editedContent).length : editedContent.length,
turn_number: retryTurnNumber,
is_multimodal: Array.isArray(editedContent)
},
tools: {
total: Object.keys(enabledToolsFlags).length,
flags: enabledToolsFlags
},
context: {
input_method: "edit_retry",
conductor_mode: false,
current_chat: currentChatId
}
},
timestamp: new Date().toISOString()
}
],
metadata: {
endpoint: "user_input_retry",
timestamp: new Date().toISOString(),
tools: Object.keys(enabledToolsFlags).length
},
currentTurnNumber: retryTurnNumber
};
// Add API request info to debug data
userDebugData.sequence.push({
type: "ai_http_request",
step: userDebugData.sequence.length + 1,
timestamp: new Date().toISOString(),
data: {
requestId: requestId,
endpoint: "chat",
message: editedContent,
tools_enabled: Object.keys(enabledToolsFlags).length,
turn_number: retryTurnNumber
}
});
userDebugData.apiRequest = {
url: `${window.location.origin}/api/chat`,
method: "POST",
requestId: requestId,
timestamp: new Date().toISOString()
};
// Save the newly generated user debug data to turn-based storage
try {
await saveTurnData(currentChatId, retryTurnNumber, userDebugData);
logger.info(`[EDIT-RETRY] Saved new user debug data for turn ${retryTurnNumber}`);
} catch (error) {
logger.warn("[EDIT-RETRY] Failed to save new user turn debug data:", error);
}
// Manually create the edited user bubble (like simpleChatMode does)
this.renderTurn(
{
role: "user",
content: editedContent,
turn_number: retryTurnNumber,
debug_data: userDebugData // Pass the newly generated debug data
},
true
);
// Generate assistant response to the edited user message
// Send the proper content format to the AI (multimodal array or text string)
const requestInfo = initiateMessageRequest(
editedContent, // This is now properly reconstructed (array for multimodal, string for
text)
false,
enabledToolsFlags,
null,
null,
false,
false,
requestId
);
const response = await requestInfo.fetchPromise;
// Process the streaming response
await this.processRetryResponse(response, currentChatId, retryTurnNumber + 1, requestId);
// Update branch navigation
setTimeout(async () => {
await this.refreshBranchNavigation();
}, 100);
} else {
// Regular edit - reload chat and refresh branch navigation
await loadChatHistory(currentChatId);
// Refresh branch navigation in case the edit created new branches
setTimeout(async () => {
await this.refreshBranchNavigation();
}, 100);
}
} catch (error) {
console.error("[EDIT] Error in exitMessageEditMode:", error);
}
}
// Handle message metadata (preview, title generation)
handleTurnMeta(role, content) {
if (role === "user" || role === "assistant") {
updateChatPreview(currentChatId, content);
// Auto-generate chat title from first user message
if (role === "user") {
const chatItem = document.querySelector(`[data-chat-id="${currentChatId}"]`);
if (chatItem) {
const currentTitle = chatItem.querySelector(".chat-item-title").textContent;
if (currentTitle === "New Chat") {
const textContent = this.getTextContent(content);
const newTitle = textContent.substring(0, 30) + (textContent.length > 30 ? "..." :
"");
updateChatTitle(newTitle);
}
}
}
}
}
// Extract plain text from blocks for preview/title generation
extractTextFromBlocks(blocks) {
if (!blocks) return "";
return blocks
.filter((block) => block.type === "chat")
.map((block) => block.content)
.join(" ");
}
// ===== BRANCH NAVIGATION SYSTEM =====
// Update brnch navigation
async updateBranchNavigation(branchNavElement, turnNumber) {
if (!currentChatId || !turnNumber) {
branchNavElement.style.display = "none";
return;
}
try {
const branchInfo = await getChatBranches(currentChatId);
const { branches, activeBranch, totalBranches } = branchInfo;
if (!branches || branches.length <= 1) {
branchNavElement.style.display = "none";
return false;
}
// Only show navigation on actual branch points (where branches diverge)
const isBranchPoint = branches.some((branch) => branch.branch_point_turn === turnNumber);
if (!isBranchPoint) {
// This turn is not a branch connection point - hide navigation
branchNavElement.style.display = "none";
return false;
}
// Build hierarchical branch tree
const branchTree = this.buildBranchTree(branches);
// Find all branches that contain this turn, considering hierarchy
const turnBranches = this.findBranchesForTurn(branches, branchTree, turnNumber, activeBranch);
if (turnBranches.length <= 1) {
// No alternative versions of this turn exist
branchNavElement.style.display = "none";
return false;
}
// Sort branches by hierarchy (ancestor -> descendant)
const sortedBranches = this.sortBranchesByHierarchy(turnBranches, branchTree);
// Find which branch in the original split is the ancestor of the current active branch
// This preserves the original branching relationships regardless of current branch
let currentBranchIndex = -1;
// If active branch is directly in the turn branches, use it
currentBranchIndex = sortedBranches.findIndex((b) => b.is_active);
if (currentBranchIndex === -1) {
// Active branch not in turn branches - find which turn branch is its ancestor
const ancestorBranch = this.findAncestorInBranches(activeBranch, sortedBranches,
branchTree);
if (ancestorBranch) {
currentBranchIndex = sortedBranches.findIndex((b) => b.id === ancestorBranch.id);
} else {
// Fallback to first branch if no ancestor found
currentBranchIndex = 0;
console.warn(
`[BRANCH-NAV] Turn ${turnNumber}: Could not find ancestor, defaulting to first
branch`
);
}
}
if (currentBranchIndex === -1 || sortedBranches.length === 0) {
branchNavElement.style.display = "none";
return false;
}
// Update navigation elements
const prevBtn = branchNavElement.querySelector(".branch-prev");
const nextBtn = branchNavElement.querySelector(".branch-next");
const indicator = branchNavElement.querySelector(".branch-indicator");
// Enable/disable buttons
prevBtn.disabled = currentBranchIndex <= 0;
nextBtn.disabled = currentBranchIndex >= sortedBranches.length - 1;
// Update indicator with branch names, showing original split relationship
const currentBranch = sortedBranches[currentBranchIndex];
indicator.textContent = `${currentBranch.branch_name} (${currentBranchIndex +
1}/${sortedBranches.length})`;
indicator.title = `Turn ${turnNumber} original split: ${sortedBranches.map((b) =>
b.branch_name).join("  ")} (preserved regardless of current branch)`;
// Store branch data for navigation
branchNavElement._turnBranches = sortedBranches;
branchNavElement._currentIndex = currentBranchIndex;
branchNavElement._turnNumber = turnNumber;
// Show navigation
branchNavElement.style.display = "flex";
branchNavElement.style.alignItems = "center";
branchNavElement.style.gap = "6px";
branchNavElement.style.marginLeft = "10px";
return true;
} catch (error) {
console.error(`[BRANCH-NAV] Error getting branches:`, error);
branchNavElement.style.display = "none";
return false;
}
}
// Build hierarchical branch tree from parent-child relationships
buildBranchTree(branches) {
const tree = new Map();
// Initialize tree with all branches
branches.forEach((branch) => {
tree.set(branch.id, {
...branch,
children: [],
depth: 0
});
});
// Build parent-child relationships and calculate depths
branches.forEach((branch) => {
if (branch.parent_branch_id) {
const parent = tree.get(branch.parent_branch_id);
const child = tree.get(branch.id);
if (parent && child) {
parent.children.push(child);
child.depth = parent.depth + 1;
}
}
});
return tree;
}
// Find branches that are relevant at a specific branch point
findBranchesForTurn(branches, branchTree, turnNumber, activeBranch) {
if (!activeBranch) return [];
// Get active lineage
const activeLineage = this.getBranchLineage(branchTree.get(activeBranch.id), branchTree);
const activeLineageIds = new Set(activeLineage.map((b) => b.id));
const result = [];
// Find all branches that branch at this exact turn
const branchesAtThisTurn = branches.filter((branch) => branch.branch_point_turn === turnNumber);
if (branchesAtThisTurn.length === 0) {
return [];
}
// KEY FIX: Only show navigation if the active branch was directly involved in this split
// Check if active branch exists at this turn (created at or before this turn)
const activeBranchTurn = activeBranch.branch_point_turn;
if (activeBranchTurn && activeBranchTurn < turnNumber) {
return [];
}
// Filter branches to only those relevant to active lineage
const relevantBranchesAtThisTurn = branchesAtThisTurn.filter((branch) => {
const branchInLineage = activeLineageIds.has(branch.id);
const parentInLineage = activeLineageIds.has(branch.parent_branch_id);
return branchInLineage || parentInLineage;
});
if (relevantBranchesAtThisTurn.length === 0) {
return [];
}
// ADDITIONAL CHECK: Active branch must be directly involved
const activeBranchDirectlyInvolved =
relevantBranchesAtThisTurn.some((b) => b.id === activeBranch.id) || // Active branch splits here
relevantBranchesAtThisTurn.some((b) => b.parent_branch_id === activeBranch.id); // Active branch
is parent
if (!activeBranchDirectlyInvolved) {
return [];
}
// Find the parent branch for this turn (use first relevant branch)
const firstRelevantBranch = relevantBranchesAtThisTurn[0];
let parentBranch = null;
if (firstRelevantBranch.parent_branch_id) {
parentBranch = branches.find((b) => b.id === firstRelevantBranch.parent_branch_id);
// Only include parent if it's also in active lineage
const parentInLineage = parentBranch && activeLineageIds.has(parentBranch.id);
if (parentInLineage) {
result.push(parentBranch);
}
}
// Add all relevant branches that actually split at this turn
relevantBranchesAtThisTurn.forEach((branch) => {
const alreadyInResult = result.find((b) => b.id === branch.id);
if (!alreadyInResult) {
result.push(branch);
}
});
return result;
}
// Find which branch in a list is an ancestor of the given branch
findAncestorInBranches(targetBranch, candidateBranches, branchTree) {
if (!targetBranch || !candidateBranches || candidateBranches.length === 0) {
return null;
}
// Get the complete ancestry of the target branch
const targetBranchNode = branchTree.get(targetBranch.id);
if (!targetBranchNode) {
return null;
}
const ancestryChain = this.getBranchLineage(targetBranchNode, branchTree);
// Find the first ancestor that exists in the candidate branches
// (working backwards from the target branch to root)
for (let i = ancestryChain.length - 1; i >= 0; i--) {
const ancestor = ancestryChain[i];
const found = candidateBranches.find((candidate) => candidate.id === ancestor.id);
if (found) {
return found;
}
}
return null;
}
// Get the complete lineage (ancestry path) of a branch
getBranchLineage(branch, branchTree) {
const lineage = [];
let current = branch;
// Walk up the ancestry chain
while (current) {
lineage.unshift(current); // Add to beginning to maintain order
if (current.parent_branch_id) {
current = branchTree.get(current.parent_branch_id);
} else {
break;
}
}
return lineage;
}
// Get all descendants of a branch
getBranchDescendants(branch, branchTree) {
const descendants = [];
function collectDescendants(node) {
node.children.forEach((child) => {
descendants.push(child);
collectDescendants(child);
});
}
collectDescendants(branch);
return descendants;
}
// Check if a branch contains a specific turn
branchHasTurn(branch, turnNumber) {
// A branch contains a turn if:
// 1. It's the main branch (has all turns before any branch point)
// 2. For other branches:
// - Turns BEFORE the branch point come from the parent branch
// - Turns AT OR AFTER the branch point are the branch's own versions
if (!branch.branch_point_turn || branch.branch_point_turn === null) {
// Main branch - contains all turns that exist
return true;
}
// For branches with a branch point:
// - They inherit all turns from parent up to (but not including) the branch point
// - They have their own versions from the branch point onwards
// So they contain ALL turns, but different versions depending on the turn number
return true;
// Future enhancement: Could check actual message existence in database
// const hasMessageQuery = `SELECT COUNT(*) as count FROM branch_messages
// WHERE branch_id = ? AND turn_number = ?`;
// return count > 0;
}
// Sort branches by hierarchy (ancestor first, then descendants)
sortBranchesByHierarchy(branches, branchTree) {
return branches.sort((a, b) => {
const nodeA = branchTree.get(a.id);
const nodeB = branchTree.get(b.id);
if (!nodeA || !nodeB) return 0;
// Sort by depth first (ancestors before descendants)
if (nodeA.depth !== nodeB.depth) {
return nodeA.depth - nodeB.depth;
}
// Same depth - sort by creation time
return new Date(a.created_at) - new Date(b.created_at);
});
}
// Navigate to previous/next branch
async navigateBranch(direction, branchNavElement = null) {
let targetBranchNav = branchNavElement;
// Fallback to finding any branch nav element if none provided (for backward compatibility)
if (!targetBranchNav) {
const branchNavElements = document.querySelectorAll(".branch-nav");
for (const nav of branchNavElements) {
if (nav._turnBranches && nav._currentIndex !== undefined) {
targetBranchNav = nav;
break;
}
}
}
if (!targetBranchNav || !targetBranchNav._turnBranches) {
console.error("[BRANCH-NAV] No branch data found for navigation");
return;
}
const turnBranches = targetBranchNav._turnBranches;
const currentIndex = targetBranchNav._currentIndex;
const turnNumber = targetBranchNav._turnNumber;
let newIndex;
if (direction === "prev") {
newIndex = Math.max(0, currentIndex - 1);
} else if (direction === "next") {
newIndex = Math.min(turnBranches.length - 1, currentIndex + 1);
} else {
return;
}
if (newIndex === currentIndex) {
return; // No change needed
}
const currentBranch = turnBranches[currentIndex];
const targetBranch = turnBranches[newIndex];
await this.switchBranch(targetBranch.id);
}
// Switch to a different branch
async switchBranch(branchId) {
if (!branchId || !currentChatId) return;
try {
// Activate the new branch
await activateChatBranch(currentChatId, parseInt(branchId));
// Reload the chat to show the new branch (this will trigger debug panel updates)
await loadChatHistory(currentChatId);
// Refresh branch navigation for all turns after switching
setTimeout(async () => {
await this.refreshBranchNavigation();
}, 100);
} catch (error) {
console.error("[BRANCH-NAV] Error switching branch:", error);
}
}
// Process streaming response for retry (without creating new user message)
async processRetryResponse(response, chatId, turnNumber, requestId) {
try {
const processor = new StreamingMessageProcessor();
const tempContainer = document.createElement("div");
const liveRenderer = new ChatRenderer(tempContainer);
// Set up tool event source for live rendering using provided requestId
let toolEventSource = null;
try {
const eventSourceUrl = `${window.location.origin}/api/tools/${requestId}`;
toolEventSource = new EventSource(eventSourceUrl);
toolEventSource.onmessage = function (event) {
try {
const eventData = JSON.parse(event.data);
handleToolEvent(eventData, processor, liveRenderer, tempContainer);
} catch (parseError) {
console.warn("Failed to parse tool event:", parseError);
}
};
} catch (error) {
logger.warn("Failed to connect to tool events:", error);
}
// Create assistant turn div manually (like simpleChatMode does)
const assistantTurnDiv = document.createElement("div");
assistantTurnDiv.className = "turn assistant-turn";
assistantTurnDiv.innerHTML = "";
this.container.appendChild(assistantTurnDiv);
// Add temp container for live rendering
assistantTurnDiv.appendChild(tempContainer);
// Process streaming response
for await (const chunk of streamResponse(response)) {
processor.addChunk(chunk);
updateLiveRendering(processor, liveRenderer, tempContainer);
smartScrollToBottom(scrollContainer);
}
// Close tool events stream
if (toolEventSource) {
toolEventSource.close();
}
// Finalize the processor
processor.finalize();
// Get debug data
let debugData = null;
if (requestId) {
try {
const debugResponse = await fetch(`${window.location.origin}/api/debug/${requestId}`);
if (debugResponse.ok) {
debugData = await debugResponse.json();
}
} catch (error) {
logger.warn("Failed to fetch debug data:", error);
}
}
// Get dropdown states before removing temp container
const dropdownStates = {};
const streamingDropdowns = tempContainer.querySelectorAll(".streaming-dropdown");
let thinkingIndex = 0;
let toolIndex = 0;
streamingDropdowns.forEach((streamingDropdown) => {
const instance = streamingDropdown._streamingDropdownInstance;
if (instance) {
let stateKey;
if (instance.type === "thinking") {
stateKey = "thinking_" + thinkingIndex;
thinkingIndex++;
} else if (instance.type === "tool") {
stateKey = "tool_" + toolIndex;
toolIndex++;
}
if (stateKey) {
dropdownStates[stateKey] = !instance.isCollapsed;
}
}
});
// Remove temp content and re-render
tempContainer.remove();
assistantTurnDiv.remove();
if (debugData) {
debugData.currentTurnNumber = turnNumber;
}
// Get final blocks and re-render
const finalBlocks = processor.getBlocks();
const renderedTurn = this.renderTurn(
{
role: "assistant",
blocks: finalBlocks,
content: processor.getRawContent() || "",
debug_data: debugData,
dropdownStates: dropdownStates,
turn_number: turnNumber
},
true
);
// Save debug data
if (debugData) {
await saveTurnData(chatId, turnNumber, debugData);
logger.info(`[RETRY] Saved debug data for turn ${turnNumber}`);
}
logger.info("[RETRY] Assistant response completed successfully");
} catch (error) {
logger.error("[RETRY] Error processing response:", error);
throw error;
}
}
// Refresh branch navigation for all turns
async refreshBranchNavigation() {
try {
// Get branch navigations for both user and assistant turns
const allTurns = document.querySelectorAll(".user-turn, .assistant-turn");
for (const turn of allTurns) {
const branchNav = turn.querySelector(".branch-nav");
const turnNumber = parseInt(turn.dataset.turnNumber);
if (branchNav && turnNumber) {
await this.updateBranchNavigation(branchNav, turnNumber);
}
}
} catch (error) {
console.error("[BRANCH-NAV] Error refreshing branch navigation:", error);
}
}
}
// Global renderer instance
let chatRenderer = null;
// Initialize renderer when DOM is ready
function initializeChatRenderer() {
const turnsContainer = document.getElementById("messages");
if (turnsContainer) {
chatRenderer = new ChatRenderer(turnsContainer);
logger.info("[RENDERER] ChatRenderer initialized");
}
}
// Ensure renderer is initialized
if (document.readyState === "loading") {
document.addEventListener("DOMContentLoaded", initializeChatRenderer);
} else {
initializeChatRenderer();
main.js:
}
// Create debug panel DOM element using sequential debug system
function createDebugPanel(turnDiv, messageId, debugData, turnNumber = null) {
const debugPanel = document.createElement("div");
debugPanel.className = "debug-panel-container";
debugPanel.dataset.messageId = messageId;
debugPanel.style.display = "none"; // Initially hidden
debugPanel.style.width = "100%";
debugPanel.style.boxSizing = "border-box";
// Inject correct turn number and turn ID from frontend
if (turnNumber !== null && debugData) {
debugData.currentTurnNumber = turnNumber;
}
// Add turn ID and message ID to debug data
if (!debugData) {
debugData = {};
}
debugData.turnId = turnDiv.closest(".turn")?.dataset.turnId || "unknown";
debugData.messageId = messageId || "unknown";
// Use the new sequential debug panel
debugPanel.innerHTML = createDebugPanelContent(debugData);
// Force width on all debug dropdowns
setTimeout(() => {
const dropdowns = debugPanel.querySelectorAll(".debug-dropdown");
dropdowns.forEach((dropdown) => {
dropdown.style.width = "100%";
dropdown.style.boxSizing = "border-box";
const content = dropdown.querySelector(".debug-dropdown-content");
if (content) {
content.style.width = "100%";
content.style.boxSizing = "border-box";
const pre = content.querySelector("pre");
if (pre) {
pre.style.width = "100%";
pre.style.boxSizing = "border-box";
}
}
});
}, 0);
return debugPanel;
}
// Main application logic - App initialization, DOM setup, and message routing
// DOM elements
let messageInput, sendBtn, turnsContainer, scrollContainer, conductorModeCheckbox;
let settingsModal, settingsBtn, newChatBtn, closeModalBtn;
let apiUrlInput, apiKeyInput, modelNameInput, modelSelectDropdown, mainModelSelect, refreshModelsBtn,
saveSettingsBtn, debugPanelsInput, testConnectionBtn;
// File upload elements
let fileInput, addFileBtn, imagePreviews, documentPreviews, imageArea, toolsBtn;
// Legacy thinking variables removed
let mcpServersDiv;
let mcpConfigModal, mcpConfigBtn, closeMcpModalBtn, mcpConfigText, saveMcpConfigBtn, testMcpConfigBtn;
let chatList, chatTitle, chatInfo;
// Chat state
let chatHistories = new Map(); // Store chat histories locally
let currentTurnNumber = 0; // Track current turn number for active chat
// Initialize the application
document.addEventListener('DOMContentLoaded', function() {
initializeElements();
setupEventListeners();
loadInitialSettings();
updateMCPStatus();
// Auto-connect to MCP servers at startup
setTimeout(autoConnectMCP, 200);
// Load chat list after a short delay to ensure DOM is ready
setTimeout(loadChatList, 300);
logger.info('Simple Chat initialized');
});
// Shared utility function for getting enabled tool definitions
async function getEnabledToolDefinitions() {
let enabledToolDefinitions = [];
try {
// Ensure enabled tools cache is loaded before checking tool status
await loadEnabledToolsFromBackend();
const mcpStatus = await getMCPStatus();
if (mcpStatus.connected && mcpStatus.servers) {
mcpStatus.servers.forEach(server => {
if (server.connected && server.tools) {
server.tools.forEach(toolName => {
if (isToolEnabled(server.name, toolName)) {
enabledToolDefinitions.push({
name: toolName,
server: server.name,
type: 'function'
});
}
});
}
});
}
} catch (error) {
logger.warn('Failed to get MCP tools:', error);
}
return enabledToolDefinitions;
}
// Turn management functions
function getNextTurnNumber() {
return ++currentTurnNumber;
}
function resetTurnTracking() {
currentTurnNumber = 0;
}
async function initializeTurnTrackingForChat(chatId) {
try {
if (!chatId) {
resetTurnTracking();
return;
}
// Get the highest turn number from this chat
const response = await getCurrentTurnNumber(chatId);
currentTurnNumber = response.turn_number || 0;
logger.debug(`[TURN] Initialized turn tracking for chat ${chatId}:
currentTurnNumber=${currentTurnNumber}`);
} catch (error) {
logger.warn('[TURN] Failed to initialize turn tracking, starting from 0:', error);
resetTurnTracking();
}
}
// Handle sending a message
async function handleSendMessage() {
const sendBtn = document.getElementById('sendBtn');
// Check if we're in stop mode
if (sendBtn.classList.contains('btn-stop')) {
stopGeneration();
return;
}
const textMessage = messageInput.value; // Don't trim - preserve user's intentional whitespace
const images = getSelectedImages();
const documents = getSelectedDocuments();
// Need either text, images, or documents
if (!textMessage && images.length === 0 && documents.length === 0) return;
// Create separated file content (no frontend concatenation)
let messageContent;
if (images.length > 0 || documents.length > 0) {
// Multimodal content with separated files
messageContent = [];
// Add text part (user text only, no document content)
if (textMessage) {
messageContent.push({
type: 'text',
text: textMessage
});
}
// Add image parts
images.forEach(imageData => {
messageContent.push({
type: 'image',
imageData: imageData.data,
mimeType: imageData.mimeType
});
});
// Add files as separate part (NEW STRUCTURE)
if (documents.length > 0) {
messageContent.push({
type: 'files',
files: documents.map(doc => ({
fileName: doc.fileName,
extractedText: doc.extractedText,
size: doc.size,
type: doc.type || 'application/octet-stream'
}))
});
}
const parts = [];
if (textMessage) parts.push('text');
if (documents.length > 0) parts.push(`${documents.length} file(s)`);
if (images.length > 0) parts.push(`${images.length} image(s)`);
logger.info(`Sending separated multimodal message: ${parts.join(' + ')}`);
} else {
// Text-only content
messageContent = textMessage || '';
logger.info('Sending text-only message');
}
const isConductorMode = conductorModeCheckbox.checked;
// Clear input and files, show loading
messageInput.value = '';
clearSelectedImages();
clearSelectedDocuments();
setLoading(true);
try {
// Get clean conversation history once using our utility function
// Use text for logging, but we'll send the full messageContent
const logMessage = typeof messageContent === 'string' ? messageContent : textMessage || '[Images
only]';
const conversationHistory = await getCleanConversationHistory(currentChatId, logMessage);
if (isConductorMode) {
// Use conductor mode with block system
await handleConductorChat(messageContent, conversationHistory);
} else {
// Simple chat mode
await handleSimpleChat(messageContent, conversationHistory);
}
} catch (error) {
if (error.name === 'AbortError') {
logger.info('Message generation was stopped by user');
} else {
showError(`Failed to send message: ${error.message}`);
}
} finally {
setLoading(false);
messageInput.focus();
}
}
// Handle conductor chat using blocks
async function handleConductorChat(message, conversationHistory) {
logger.info('[CONDUCTOR] Starting conductor mode with blocks');
// Get settings and tools for debug data
const settings = loadSettings();
const enabledToolDefinitions = await getEnabledToolDefinitions();
// Create user debug data using sequence format
const userDebugData = {
sequence: [
{
type: 'user_input',
step: 1,
data: {
userQuery: {
message: message,
chat_id: currentChatId,
conductor_mode: true,
timestamp: new Date().toISOString(),
message_length: message.length
},
tools: {
total: enabledToolDefinitions.length,
definitions: enabledToolDefinitions
},
context: {
input_method: 'manual',
conductor_mode: true,
current_chat: currentChatId
}
},
timestamp: new Date().toISOString()
}
],
metadata: {
endpoint: 'user_input',
timestamp: new Date().toISOString(),
tools: enabledToolDefinitions.length
}
};
// Use same field names as assistant debug data for consistency
userDebugData.completeMessageHistory = conversationHistory || [];
userDebugData.currentTurnNumber = userTurnNumber;
// Get turn number for this user message
const userTurnNumber = getNextTurnNumber();
// Add user message to UI using unified renderer
chatRenderer.renderTurn({
role: 'user',
content: message,
debug_data: userDebugData,
turn_number: userTurnNumber
}, true);
// Save user message and debug data separately (turn-based approach)
try {
// Save user message with separated file structure
const messageForSaving = { role: 'user', content: message };
// If message contains files, store original content and file metadata
if (Array.isArray(message)) {
const filesPart = message.find(part => part.type === 'files');
if (filesPart && filesPart.files) {
messageForSaving.original_content = message;
messageForSaving.file_metadata = {
hasFiles: true,
fileCount: filesPart.files.length,
imageCount: message.filter(part => part.type === 'image').length,
files: filesPart.files
};
}
}
await saveCompleteMessage(currentChatId, messageForSaving, null, userTurnNumber);
// Save debug data to turn-based storage
if (userDebugData) {
await saveTurnData(currentChatId, userTurnNumber, userDebugData);
logger.info(`[TURN-DEBUG] Saved user debug data for turn ${userTurnNumber}`);
}
} catch (error) {
logger.warn('Failed to save user message or debug data:', error);
}
// Create assistant message div (same pattern as simple chat)
const assistantMessageDiv = document.createElement('div');
assistantMessageDiv.className = 'message assistant';
assistantMessageDiv.innerHTML = '';
turnsContainer.appendChild(assistantMessageDiv);
try {
// Initialize conductor
const conductor = new Conductor();
// Run conductor and get result
const result = await conductor.runConductor(message, assistantMessageDiv);
// Get turn number and inject it into debug data BEFORE creating final message data
const assistantTurnNumber = getNextTurnNumber();
if (result.debugData) {
result.debugData.currentTurnNumber = assistantTurnNumber;
}
// Prepare final content BEFORE removing temp elements (seamless transition)
const finalMessageData = {
role: 'assistant',
content: result.content || '',
debug_data: result.debugData,
dropdownStates: result.dropdownStates || {},
isPartial: result.wasAborted,
turn_number: assistantTurnNumber
};
// Create final content off-screen (no flicker!)
const finalContent = chatRenderer.createTurnElement(finalMessageData, false);
// Seamless replacement: swap content atomically
const parent = assistantMessageDiv.parentNode;
parent.replaceChild(finalContent, assistantMessageDiv);
// NOW clean up the temp container from conductor
if (conductor.tempContainer && conductor.tempContainer.parentNode) {
conductor.tempContainer.remove();
}
// Handle scrolling after replacement
smartScrollToBottom(scrollContainer);
// Check if conductor was aborted (for saving logic)
if (result.wasAborted) {
logger.info('[CONDUCTOR] Handling aborted conductor result');
// Save whatever content the AI actually generated (even if empty)
try {
// Save assistant message without debug data (turn-based approach)
await saveCompleteMessage(currentChatId, { role: 'assistant', content: result.content || ''
}, null, assistantTurnNumber);
// Save debug data to turn-based storage
if (result.debugData) {
await saveTurnData(currentChatId, assistantTurnNumber, result.debugData);
logger.info(`[TURN-DEBUG] Saved aborted debug data for turn ${assistantTurnNumber}`);
}
updateChatPreview(currentChatId, result.content || '');
} catch (saveError) {
logger.warn('[CONDUCTOR] Failed to save aborted message or debug data:', saveError);
}
return; // Exit cleanly
}
// Normal completion - already handled by seamless replacement above
// Save assistant message and debug data separately (turn-based approach)
try {
// Save assistant message without debug data
await saveCompleteMessage(currentChatId, { role: 'assistant', content: result.content }, null,
assistantTurnNumber);
// Save debug data to turn-based storage
if (result.debugData) {
await saveTurnData(currentChatId, assistantTurnNumber, result.debugData);
logger.info(`[TURN-DEBUG] Saved assistant debug data for turn ${assistantTurnNumber}`);
}
// Update chat preview with display content
updateChatPreview(currentChatId, result.content);
} catch (error) {
logger.error('[CONDUCTOR] Failed to save messages or debug data:', error);
}
logger.info('[CONDUCTOR] Conductor session completed successfully');
} catch (error) {
// Handle other errors
logger.error('[CONDUCTOR] Conductor failed:', error, true);
// Show error in UI using ChatRenderer (unified with simple chat)
assistantMessageDiv.remove();
const errorTurnNumber = getNextTurnNumber();
chatRenderer.renderTurn({
role: 'assistant',
content: `[ERROR] Conductor failed: ${error.message}`,
debug_data: null,
turn_number: errorTurnNumber
}, true);
try {
chatManager.js:
// User message was already saved above, just save the error assistant message
await saveCompleteMessage(currentChatId, { role: 'assistant', content: `Error: ${error.message}`
}, null, errorTurnNumber);
} catch (saveError) {
logger.error('[CONDUCTOR] Failed to save error message:', saveError);
}
}
}
// Chat Manager - Chat list management, switching, and history
// Utility function to safely extract text content from multimodal or string content
function getTextContent(content) {
if (typeof content === 'string') {
// Check if it's a JSON string that needs parsing
if (content.startsWith('[') || content.startsWith('{')) {
try {
const parsed = JSON.parse(content);
return getTextContent(parsed); // Recursively process parsed content
} catch (e) {
// If parsing fails, return the string as-is
return content;
}
}
return content;
}
if (Array.isArray(content)) {
// Extract text from multimodal array
const textPart = content.find(part => part.type === 'text');
const filesPart = content.find(part => part.type === 'files');
const imageParts = content.filter(part => part.type === 'image');
// Priority: text content first
if (textPart && textPart.text) {
// If there's text plus other content, show text with indicators
const extras = [];
if (filesPart && filesPart.files && filesPart.files.length > 0) {
if (filesPart.files.length === 1) {
const file = filesPart.files[0];
const fileName = file.fileName || file.name || file.originalName || 'Unknown file';
extras.push(`[File] ${fileName}`);
} else {
extras.push(`[${filesPart.files.length} files]`);
}
}
if (imageParts.length > 0) {
if (imageParts.length === 1) {
extras.push('[Image]');
} else {
extras.push(`[${imageParts.length} images]`);
}
}
if (extras.length > 0) {
return `${textPart.text} + ${extras.join(' + ')}`;
}
return textPart.text;
}
// No text content, show files/images only
else {
const parts = [];
if (filesPart && filesPart.files && filesPart.files.length > 0) {
if (filesPart.files.length === 1) {
const file = filesPart.files[0];
const fileName = file.fileName || file.name || file.originalName || 'Unknown file';
parts.push(`[File] ${fileName}`);
} else {
parts.push(`[${filesPart.files.length} files]`);
}
}
if (imageParts.length > 0) {
if (imageParts.length === 1) {
parts.push('[Image]');
} else {
parts.push(`[${imageParts.length} images]`);
}
}
if (parts.length > 0) {
return parts.join(' + ');
} else {
return '[Multimodal content]';
}
}
}
// Handle any other data types gracefully
if (typeof content === 'object' && content !== null) {
// Try to extract something meaningful from unknown objects
if (content.type) {
return `[${content.type}]`;
}
if (content.name || content.fileName) {
return `[File] ${content.name || content.fileName}`;
}
if (Array.isArray(content)) {
return content.map(item => getTextContent(item)).join(' + ');
}
return '[Content]';
}
const result = String(content || '');
// Prevent [object Object] from ever appearing
if (result === '[object Object]') {
return '[Content]';
}
return result;
}
// Utility function to get preview text with length limit
function getPreviewText(content, maxLength = 50) {
const textContent = getTextContent(content);
if (textContent.length > maxLength) {
return textContent.substring(0, maxLength) + '...';
}
return textContent;
}
// Handle new chat
async function handleNewChat() {
try {
// Create new chat ID
currentChatId = generateId();
// Create chat in database
await createNewChatInDatabase(currentChatId, 'New Chat');
// Clear turns
turnsContainer.innerHTML = '';
// Reset turn tracking for new chat
resetTurnTracking();
// Update UI
updateChatTitle('New Chat');
chatInfo.textContent = `Chat ID: ${currentChatId}`;
// Add to chat list
addChatToList(currentChatId, 'New Chat', '', new Date());
// Select this chat
selectChat(currentChatId);
} catch (error) {
logger.error('Failed to create new chat:', error, true);
showError('Failed to create new chat');
}
// Focus input
messageInput.focus();
}
// Load chat list from backend
async function loadChatList() {
try {
const response = await fetch(`${API_BASE}/api/chats`);
if (!response.ok) {
throw new Error(`HTTP ${response.status}: ${response.statusText}`);
}
const chats = await response.json();
// Clear existing list
chatList.innerHTML = '';
if (chats.length === 0) {
// No existing chats, create an initial one
currentChatId = generateId();
try {
await createNewChatInDatabase(currentChatId, 'New Chat');
addChatToList(currentChatId, 'New Chat', '', new Date()); // This is already local time
selectChat(currentChatId);
updateChatTitle('New Chat');
chatInfo.textContent = `Chat ID: ${currentChatId}`;
} catch (error) {
logger.error('Failed to create initial chat:', error, true);
chatList.innerHTML = '<div style="padding: 8px; color: #666; font-style: italic; text-align:
center;">Error creating initial chat.</div>';
}
return;
}
// Add each chat to the list (backend returns newest-first, so append to maintain order)
chats.forEach(chat => {
addChatToListAtEnd(chat.chat_id, chat.title, chat.last_message, new Date(chat.last_updated));
});
// Auto-select the most recent chat
if (chats.length > 0) {
const mostRecent = chats[0];
currentChatId = mostRecent.chat_id;
selectChat(currentChatId);
loadChatHistory(currentChatId);
}
} catch (error) {
logger.error('Error loading chat list:', error, true);
chatList.innerHTML = '<div style="padding: 8px; color: #666; font-style: italic; text-align:
center;">No chats available.</div>';
}
}
// Add chat to the sidebar list
// Helper function to format date/time smartly
function formatChatDateTime(date) {
const now = new Date();
const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
const chatDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
const timeStr = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
if (chatDate.getTime() === today.getTime()) {
return `Today ${timeStr}`;
} else if (chatDate.getTime() === yesterday.getTime()) {
return `Yesterday ${timeStr}`;
} else {
const dateStr = date.toLocaleDateString('en-US', {
month: 'numeric',
day: 'numeric',
year: 'numeric'
});
return `${dateStr} ${timeStr}`;
}
}
function addChatToList(chatId, title, lastMessage, lastUpdated) {
const chatItem = document.createElement('div');
chatItem.className = 'chat-item';
chatItem.dataset.chatId = chatId;
const dateTimeStr = formatChatDateTime(lastUpdated);
chatItem.innerHTML = `
<div class="chat-item-header">
<div class="chat-item-datetime">${dateTimeStr}</div>
<button class="chat-delete-btn" title="Delete chat"><span class="x-icon"></span></button>
</div>
<div class="chat-item-content">
<div class="chat-item-title">${escapeHtml(title)}</div>
<div class="chat-item-preview">${escapeHtml(getPreviewText(lastMessage, 50))}</div>
</div>
`;
// Add click handler for the main chat content (but not the header)
const chatContent = chatItem.querySelector('.chat-item-content');
chatContent.addEventListener('click', () => {
switchToChat(chatId);
});
// Also allow clicking the main chat item (but not header or delete button)
chatItem.addEventListener('click', (e) => {
if (!e.target.closest('.chat-item-header')) {
switchToChat(chatId);
}
});
// Add click handler for the delete button
const deleteBtn = chatItem.querySelector('.chat-delete-btn');
deleteBtn.addEventListener('click', (e) => {
e.stopPropagation(); // Prevent chat selection
handleDeleteChat(chatId, title);
});
// Insert at the top (most recent first)
chatList.insertBefore(chatItem, chatList.firstChild);
}
// Add chat to the sidebar list at the end (for loading from database)
function addChatToListAtEnd(chatId, title, lastMessage, lastUpdated) {
const chatItem = document.createElement('div');
chatItem.className = 'chat-item';
chatItem.dataset.chatId = chatId;
const dateTimeStr = formatChatDateTime(lastUpdated);
chatItem.innerHTML = `
<div class="chat-item-header">
<div class="chat-item-datetime">${dateTimeStr}</div>
<button class="chat-delete-btn" title="Delete chat"><span class="x-icon"></span></button>
</div>
<div class="chat-item-content">
<div class="chat-item-title">${escapeHtml(title)}</div>
<div class="chat-item-preview">${escapeHtml(getPreviewText(lastMessage, 50))}</div>
</div>
`;
// Add click handler for the main chat content (but not the header)
const chatContent = chatItem.querySelector('.chat-item-content');
chatContent.addEventListener('click', () => {
switchToChat(chatId);
});
// Also allow clicking the main chat item (but not header or delete button)
chatItem.addEventListener('click', (e) => {
if (!e.target.closest('.chat-item-header')) {
switchToChat(chatId);
}
});
// Add click handler for the delete button
const deleteBtn = chatItem.querySelector('.chat-delete-btn');
deleteBtn.addEventListener('click', (e) => {
e.stopPropagation(); // Prevent chat selection
handleDeleteChat(chatId, title);
});
// Append at the end (maintain backend order)
chatList.appendChild(chatItem);
}
// Handle chat deletion with confirmation
async function handleDeleteChat(chatId, title) {
// Use custom confirm instead of browser popup
showCustomConfirm(
`Delete chat "${title}"?\n\nThis will permanently delete all messages in this chat.`,
async () => {
await performChatDeletion(chatId, title);
}
);
}
// Separate function to perform the actual deletion
async function performChatDeletion(chatId, title) {
try {
const response = await fetch(`${API_BASE}/api/chat/${chatId}`, {
method: 'DELETE'
});
if (!response.ok) {
throw new Error(`HTTP ${response.status}: ${response.statusText}`);
}
// Remove the chat item from the UI
const chatItem = document.querySelector(`[data-chat-id="${chatId}"]`);
if (chatItem) {
chatItem.remove();
}
// If this was the current chat, switch to another or clear
if (currentChatId === chatId) {
const remainingChats = document.querySelectorAll('.chat-item');
if (remainingChats.length > 0) {
// Switch to the first remaining chat
const firstChatId = remainingChats[0].dataset.chatId;
await switchToChat(firstChatId);
} else {
// No chats left, create a new one
await handleNewChat();
}
}
logger.info('Chat deleted successfully:', chatId);
} catch (error) {
logger.error('Failed to delete chat:', error, true);
showError(`Failed to delete chat: ${error.message}`);
}
}
// Select a chat in the UI
function selectChat(chatId) {
// Remove active class from all chat items
document.querySelectorAll('.chat-item').forEach(item => {
item.classList.remove('active');
});
// Add active class to selected chat
const selectedItem = document.querySelector(`[data-chat-id="${chatId}"]`);
if (selectedItem) {
selectedItem.classList.add('active');
}
}
// Switch to a different chat
async function switchToChat(chatId) {
if (chatId === currentChatId) return;
currentChatId = chatId;
selectChat(chatId);
// Load chat history
await loadChatHistory(chatId);
// Focus input
messageInput.focus();
}
// Reconstruct tool content from message relationships
function reconstructToolContent(messages) {
const processedMessages = [];
let i = 0;
while (i < messages.length) {
const msg = messages[i];
// Check if this is an assistant message with tool calls
if (msg.role === 'assistant' && hasToolCalls(msg)) {
// Find all subsequent tool messages that belong to this assistant message
const toolResults = [];
let j = i + 1;
// Collect all tool messages that follow this assistant message
while (j < messages.length && messages[j].role === 'tool') {
toolResults.push(messages[j]);
j++;
}
// Keep original content clean - no injection of fake markers
let reconstructedContent = msg.content || '';
// Add the message with tool data for SSE simulation
processedMessages.push({
...msg,
content: reconstructedContent,
tool_results: toolResults // Add tool results for SSE simulation
});
// Skip the tool messages since we've absorbed them
i = j;
} else {
// Regular message, add as-is
processedMessages.push(msg);
i++;
}
}
return processedMessages;
}
// Group messages by turn_number for proper turn-based rendering
function groupMessagesByTurn(messages) {
const turnGroups = new Map();
messages.forEach(msg => {
const turnNumber = msg.turn_number || 0;
if (!turnGroups.has(turnNumber)) {
turnGroups.set(turnNumber, []);
}
turnGroups.get(turnNumber).push(msg);
});
// Check for duplicate turn numbers in the groups
const turnNumbers = Array.from(turnGroups.keys());
const duplicateTurns = turnNumbers.filter((turn, index) => turnNumbers.indexOf(turn) !== index);
if (duplicateTurns.length > 0) {
console.error(`[GROUP-MESSAGES] DUPLICATE TURN NUMBERS DETECTED: ${duplicateTurns}`);
}
turnGroups.forEach((msgs, turnNum) => {
const assistantCount = msgs.filter(m => m.role === 'assistant').length;
if (assistantCount > 1) {
console.warn(`[GROUP-MESSAGES] Turn ${turnNum} has ${assistantCount} assistant messages!`);
}
});
// Convert to array and sort by turn number
return Array.from(turnGroups.entries())
.sort(([a], [b]) => a - b)
.map(([turnNumber, turnMessages]) => ({ turnNumber, messages: turnMessages }));
}
// Check if a message has tool calls
function hasToolCalls(msg) {
// Check if tool_calls field exists
if (msg.tool_calls && Array.isArray(msg.tool_calls) && msg.tool_calls.length > 0) {
return true;
}
// Check if content mentions tool calls (legacy format)
if (msg.content && msg.content.includes('tool_calls')) {
return true;
}
return false;
}
// Track if we're already loading to prevent concurrent calls
let isLoadingHistory = false;
// Load chat history for a specific chat
async function loadChatHistory(chatId) {
if (isLoadingHistory) {
console.warn(`[LOAD-GUARD] Already loading history, ignoring duplicate call for chatId: ${chatId}`);
return;
}
isLoadingHistory = true;
try {
setLoading(true);
const history = await getCompleteChatHistory(chatId);
// Validate history data
if (!history || !history.messages || !Array.isArray(history.messages)) {
console.error('[LOAD-HISTORY] Invalid history data received:', history);
throw new Error('Invalid chat history data received from server');
}
// Filter out any malformed messages
const validMessages = history.messages.filter(msg => {
if (!msg || !msg.role || msg.turn_number === undefined) {
console.warn('[LOAD-HISTORY] Skipping malformed message:', msg);
return false;
}
return true;
});
if (validMessages.length !== history.messages.length) {
console.warn(`[LOAD-HISTORY] Filtered out ${history.messages.length - validMessages.length}
malformed messages`);
}
// Replace with filtered messages
history.messages = validMessages;
// Initialize turn tracking for this chat
await initializeTurnTrackingForChat(chatId);
// Clear current turns
turnsContainer.innerHTML = '';
// Reset auto-scroll state when loading new chat
isUserAtBottom = true;
// Update chat info
const chatItem = document.querySelector(`[data-chat-id="${chatId}"]`);
const title = chatItem ? chatItem.querySelector('.chat-item-title').textContent : 'Chat';
chatTitle.textContent = title; // Just update the UI title, don't save to database
chatInfo.textContent = `Chat ID: ${chatId} | ${history.messages.length} messages`;
// Using proper SSE simulation without content injection
logger.info('[UNIFIED-RENDERING] Processing chat history through SSE simulation');
// Prepare messages with tool data for SSE simulation
const processedMessages = reconstructToolContent(history.messages);
// Group messages by turn_number for proper turn-based rendering
const turnGroups = groupMessagesByTurn(processedMessages);
// Process each turn using the exact same pipeline as live rendering
turnGroups.forEach((group, groupIndex) => {
const { turnNumber, messages: turnMessages } = group;
// Separate user and assistant messages (like live rendering does)
const userMessages = turnMessages.filter(msg => msg.role === 'user');
const assistantMessages = turnMessages.filter(msg => msg.role === 'assistant');
// Check if any messages in this turn are errored
const hasErrors = turnMessages.some(msg => msg.error_state);
const errorMessages = turnMessages.filter(msg => msg.error_state);
// Check for duplicate assistant messages in the same turn
if (assistantMessages.length > 1) {
console.warn(`[LOAD-HISTORY] WARNING: Turn ${turnNumber} has ${assistantMessages.length}
assistant messages!`);
console.warn(`[LOAD-HISTORY] Assistant message IDs:`, assistantMessages.map(m => ({id: m.id,
content: getPreviewText(m.content, 50)})));
}
// Render user messages directly (exactly like live rendering)
userMessages.forEach(userMsg => {
chatRenderer.renderTurn({
id: userMsg.id,
role: 'user',
content: userMsg.content,
turn_number: turnNumber,
edit_count: userMsg.edit_count,
edited_at: userMsg.edited_at,
debug_data: userMsg.debug_data // Include debug data for user messages
}, false);
});
// Handle error messages - render them with special error styling
if (hasErrors && errorMessages.length > 0) {
errorMessages.forEach(errorMsg => {
// Create error message with debug panel
chatRenderer.renderTurn({
id: errorMsg.id,
role: 'assistant',
content: errorMsg.content,
turn_number: turnNumber,
error_state: errorMsg.error_state,
debug_data: errorMsg.debug_data,
edit_count: errorMsg.edit_count,
edited_at: errorMsg.edited_at,
blocks: [{
type: 'error',
content: errorMsg.content,
metadata: {
error_type: errorMsg.error_state,
debug_data: errorMsg.debug_data
}
}]
}, false);
});
}
// Process assistant messages separately (exactly like live rendering)
if (assistantMessages.length > 0 && !hasErrors) {
// Create a processor only for assistant content
const processor = new StreamingMessageProcessor();
// Create a temp container for use with updateLiveRendering (required by handleToolEvent)
const tempContainer = document.createElement('div');
const liveRenderer = new ChatRenderer(tempContainer);
let turnDebugData = null;
let primaryAssistantMessage = null;
assistantMessages.forEach((msg, msgIndex) => {
// Track the primary assistant message
if (msg.content) {
if (primaryAssistantMessage) {
console.warn(`[LOAD-HISTORY] Multiple assistant messages with content! Previous:
${primaryAssistantMessage.id}, Current: ${msg.id}`);
}
primaryAssistantMessage = msg;
turnDebugData = msg.debug_data;
}
// Handle only assistant content - this properly processes <think> and <thinking> tags
and normal text
if (msg.content) {
// Check if content is multimodal (array) - if so, only process text parts for
streaming processor
if (Array.isArray(msg.content)) {
const textParts = msg.content.filter(part => part.type === 'text');
textParts.forEach(part => {
if (part.text) {
processor.addChunk(part.text);
}
});
} else {
// Regular string content
processor.addChunk(msg.content);
}
}
// Simulate SSE tool events using the same structured data
if (msg.tool_calls && Array.isArray(msg.tool_calls)) {
msg.tool_calls.forEach((toolCall, toolIdx) => {
const toolName = toolCall.function?.name || 'unknown_tool';
let args;
try {
args = JSON.parse(toolCall.function?.arguments || '{}');
} catch (e) {
args = { raw: toolCall.function?.arguments || '{}' };
}
// Find corresponding tool result
const toolResult = msg.tool_results?.find(tr => tr.tool_call_id ===
toolCall.id);
// Simulate the exact same tool event sequence that live rendering receives
// 1. Tool call detected
handleToolEvent({
type: 'tool_call_detected',
data: {
id: toolCall.id,
name: toolName
}
}, processor, liveRenderer, tempContainer);
// 2. Tool execution started
handleToolEvent({
type: 'tool_execution_start',
data: {
id: toolCall.id,
name: toolName,
arguments: args
}
}, processor, liveRenderer, tempContainer);
// 3. Tool execution completed
let resultContent = { content: 'No result available' };
if (toolResult) {
try {
resultContent = JSON.parse(toolResult.content);
} catch (e) {
resultContent = { content: toolResult.content };
}
}
handleToolEvent({
type: 'tool_execution_complete',
data: {
id: toolCall.id,
name: toolName,
status: 'success',
result: resultContent,
execution_time_ms: 0
}
}, processor, liveRenderer, tempContainer);
});
}
});
// Finalize the processor after processing all assistant messages
processor.finalize();
// Get the blocks that were created through the exact same pipeline as live rendering
let blocks = processor.getBlocks();
// Determine content to render - preserve multimodal content if it exists
let contentToRender = processor.getRawContent() || '';
if (primaryAssistantMessage?.content && Array.isArray(primaryAssistantMessage.content)) {
// Use original multimodal content to preserve images
contentToRender = primaryAssistantMessage.content;
// CRITICAL FIX: Create complete blocks that include multimodal content
// The processor only created blocks from text parts, but we need to include images too
const hasImages = primaryAssistantMessage.content.some(part => part.type === 'image');
if (hasImages && blocks.length > 0) {
// Replace the first chat block with the complete multimodal content
const firstChatBlockIndex = blocks.findIndex(block => block.type === 'chat');
if (firstChatBlockIndex !== -1) {
blocks[firstChatBlockIndex] = {
type: 'chat',
content: primaryAssistantMessage.content, // Full multimodal array
metadata: {}
};
}
} else if (hasImages && blocks.length === 0) {
// No blocks were created (probably no text), but we have images - create a
multimodal block
blocks = [{
type: 'chat',
content: primaryAssistantMessage.content, // Full multimodal array
metadata: {}
}];
}
}
// Render assistant turn with complete blocks (including images)
chatRenderer.renderTurn({
id: primaryAssistantMessage?.id,
role: 'assistant',
blocks: blocks, // Now includes complete multimodal content
content: contentToRender,
debug_data: turnDebugData,
turn_number: turnNumber,
edit_count: primaryAssistantMessage?.edit_count,
edited_at: primaryAssistantMessage?.edited_at
}, false); // false = don't scroll for each turn
}
});
// Force scroll to bottom when loading chat history
scrollToBottom(scrollContainer);
} catch (error) {
logger.error('Error loading chat history:', error, true);
showError(`Failed to load chat history: ${error.message}`);
} finally {
setLoading(false);
isLoadingHistory = false;
}
}
// Update chat title
async function updateChatTitle(title) {
// Convert objects properly using text extraction
let cleanTitle = title;
// If title is an object/array, extract text content
if (typeof title === 'object') {
cleanTitle = getTextContent(title) || 'New Chat';
}
// Fallback for invalid strings
if (!cleanTitle || cleanTitle === 'undefined' || cleanTitle === 'null' || cleanTitle.includes('[object
Object]')) {
cleanTitle = 'New Chat';
}
chatTitle.textContent = cleanTitle;
// Update the chat item in the list too
const chatItem = document.querySelector(`[data-chat-id="${currentChatId}"]`);
if (chatItem) {
const titleEl = chatItem.querySelector('.chat-item-title');
if (titleEl) {
titleEl.textContent = cleanTitle;
// Update the title in the database
try {
await updateChatTitleInDatabase(currentChatId, cleanTitle);
} catch (error) {
logger.error('Error updating chat title in database:', error);
// Continue anyway - UI is updated even if DB update fails
}
}
}
}
// Update chat preview in the list
function updateChatPreview(chatId, message) {
const chatItem = document.querySelector(`[data-chat-id="${chatId}"]`);
if (chatItem) {
const previewEl = chatItem.querySelector('.chat-item-preview');
if (previewEl) {
// Process the message through getTextContent first to handle multimodal content
const processedText = getTextContent(message);
previewEl.textContent = getPreviewText(processedText, 50);
}
// Update timestamp
const timeEl = chatItem.querySelector('.chat-item-time');
if (timeEl) {
const now = new Date();
timeEl.textContent = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}
// Keep chat in its original position (ordered by creation time)
}
}
// Get chat history from backend
async function getChatHistory(chatId) {
try {
const response = await fetch(`${API_BASE}/api/chat/${chatId}/history`);
if (!response.ok) {
throw new Error(`HTTP ${response.status}: ${response.statusText}`);
}
return await response.json();
} catch (error) {
logger.error('Error fetching chat history:', error);
throw error;
}
}
// Get complete chat history including error messages (for UI display)
async function getCompleteChatHistory(chatId) {
try {
const response = await fetch(`${API_BASE}/api/chat/${chatId}/history-complete`);
if (!response.ok) {
throw new Error(`HTTP ${response.status}: ${response.statusText}`);
}
return await response.json();
} catch (error) {
logger.error('Error fetching complete chat history:', error);
throw error;
}
}
// Make functions globally available for UI
window.handleNewChat = handleNewChat;